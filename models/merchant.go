// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Merchant Merchant
// swagger:model Merchant
type Merchant struct {

	// The address of the merchant associated with the transaction is populated in the merchant address field.<br><b>Note</b>: The merchant address field is not available by default and customers will have to specifically request the merchant's address (that includes city, state, and ZIP of the merchant). The merchant address field is available only for merchants in the United States.<br><br><b>Applicable containers</b>: bank,creditCard<br>
	// Read Only: true
	Address *AccountAddress `json:"address,omitempty"`

	// The business categories of the merchant.<br><br><b>Applicable containers</b>: bank,creditCard<br><b>Applicable Values</b><br>
	// Read Only: true
	CategoryLabel []string `json:"categoryLabel"`

	// The merchant geolocation coordinates like latitude and longitude.<br><br><b>Applicable containers</b>: bank,creditCard,loan<br>
	Coordinates *Coordinates `json:"coordinates,omitempty"`

	// Identifier of the merchant.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
	// Read Only: true
	ID string `json:"id,omitempty"`

	// The name of the merchant.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br>
	// Read Only: true
	Name string `json:"name,omitempty"`

	// The source through which merchant information is retrieved.<br><br><b>Applicable containers</b>: bank,creditCard,investment,insurance,loan<br><b>Applicable Values</b><br>
	// * YODLEE: The source that provided the merchant information is Yodlee.<br>
	// * FACTUAL: The source that provided the merchant information is FACTUAL.<br>
	// Read Only: true
	// Enum: [YODLEE FACTUAL]
	Source string `json:"source,omitempty"`
}

// Validate validates this merchant
func (m *Merchant) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCoordinates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Merchant) validateAddress(formats strfmt.Registry) error {

	if swag.IsZero(m.Address) { // not required
		return nil
	}

	if m.Address != nil {
		if err := m.Address.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("address")
			}
			return err
		}
	}

	return nil
}

func (m *Merchant) validateCoordinates(formats strfmt.Registry) error {

	if swag.IsZero(m.Coordinates) { // not required
		return nil
	}

	if m.Coordinates != nil {
		if err := m.Coordinates.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("coordinates")
			}
			return err
		}
	}

	return nil
}

var merchantTypeSourcePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["YODLEE","FACTUAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		merchantTypeSourcePropEnum = append(merchantTypeSourcePropEnum, v)
	}
}

const (

	// MerchantSourceYODLEE captures enum value "YODLEE"
	MerchantSourceYODLEE string = "YODLEE"

	// MerchantSourceFACTUAL captures enum value "FACTUAL"
	MerchantSourceFACTUAL string = "FACTUAL"
)

// prop value enum
func (m *Merchant) validateSourceEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, merchantTypeSourcePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Merchant) validateSource(formats strfmt.Registry) error {

	if swag.IsZero(m.Source) { // not required
		return nil
	}

	// value enum
	if err := m.validateSourceEnum("source", "body", m.Source); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Merchant) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Merchant) UnmarshalBinary(b []byte) error {
	var res Merchant
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
