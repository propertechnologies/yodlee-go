// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DerivedNetworthHistoricalBalance DerivedNetworthHistoricalBalance
// swagger:model DerivedNetworthHistoricalBalance
type DerivedNetworthHistoricalBalance struct {

	// Date as of when the balance is last  updated due to the auto account updates or user triggered updates. This balance will be carry forward for the days where there is no balance available in the system. <br><br><b>Account Type</b>: Aggregated and Manual<br><b>Applicable containers</b>: bank, creditCard, investment, insurance, realEstate, loan<br><b>Endpoints</b>:<ul><li>GET accounts/historicalBalances</li></ul>
	// Read Only: true
	AsOfDate string `json:"asOfDate,omitempty"`

	// Balance amount of the account.<br><br><b>Account Type</b>: Aggregated and Manual<br><b>Applicable containers</b>: bank, creditCard, investment, insurance, realEstate, loan<br><b>Endpoints</b>:<ul><li>GET accounts/historicalBalances</li></ul>
	// Read Only: true
	Balance *Money `json:"balance,omitempty"`

	// The source of balance information.<br><br><b>Account Type</b>: Aggregated and Manual<br><b>Applicable containers</b>: bank, creditCard, investment, insurance, realEstate, loan<br><b>Endpoints</b>:<ul><li>GET accounts/historicalBalances</li></ul><b>Applicable Values</b><br>
	// * S: Scraped balance from the provider site.<br>
	// * C: Calculated balance by the system.<br>
	// * CF: Last available balance that was carry forwarded for the days when account was not updated.<br>
	// Read Only: true
	// Enum: [S C CF]
	DataSourceType string `json:"dataSourceType,omitempty"`

	// Date for which the account balance was provided.  This balance could be a carryforward, calculated or a scraped balance. AdditIonal Details: scraped: Balance shown in the provider site. This balance gets stored in Yodlee system during system/user account updates. carryForward : Balance carried forward from the scraped balance to the days for which the balance was not available in the system. Balance may not be available for all the days in the system due to MFA information required, error in the site, credential changes, etc. calculated: Balances that gets calculated for the days that are prior to the account added date.<br><br><b>Account Type</b>: Aggregated and Manual<br><b>Applicable containers</b>: bank, creditCard, investment, insurance, realEstate, loan<br><b>Endpoints</b>:<ul><li>GET accounts/historicalBalances</li><li>GET derived/networth</li></ul>
	// Read Only: true
	Date string `json:"date,omitempty"`

	// Indicates whether the balance is an asset or liability.<br><br><b>Account Type</b>: Aggregated and Manual<br><b>Applicable containers</b>: bank, creditCard, investment, insurance, realEstate, loan<br><b>Endpoints</b>:<ul><li>GET accounts/historicalBalances</li></ul>
	// Read Only: true
	IsAsset *bool `json:"isAsset,omitempty"`
}

// Validate validates this derived networth historical balance
func (m *DerivedNetworthHistoricalBalance) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataSourceType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DerivedNetworthHistoricalBalance) validateBalance(formats strfmt.Registry) error {

	if swag.IsZero(m.Balance) { // not required
		return nil
	}

	if m.Balance != nil {
		if err := m.Balance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("balance")
			}
			return err
		}
	}

	return nil
}

var derivedNetworthHistoricalBalanceTypeDataSourceTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["S","C","CF"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		derivedNetworthHistoricalBalanceTypeDataSourceTypePropEnum = append(derivedNetworthHistoricalBalanceTypeDataSourceTypePropEnum, v)
	}
}

const (

	// DerivedNetworthHistoricalBalanceDataSourceTypeS captures enum value "S"
	DerivedNetworthHistoricalBalanceDataSourceTypeS string = "S"

	// DerivedNetworthHistoricalBalanceDataSourceTypeC captures enum value "C"
	DerivedNetworthHistoricalBalanceDataSourceTypeC string = "C"

	// DerivedNetworthHistoricalBalanceDataSourceTypeCF captures enum value "CF"
	DerivedNetworthHistoricalBalanceDataSourceTypeCF string = "CF"
)

// prop value enum
func (m *DerivedNetworthHistoricalBalance) validateDataSourceTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, derivedNetworthHistoricalBalanceTypeDataSourceTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DerivedNetworthHistoricalBalance) validateDataSourceType(formats strfmt.Registry) error {

	if swag.IsZero(m.DataSourceType) { // not required
		return nil
	}

	// value enum
	if err := m.validateDataSourceTypeEnum("dataSourceType", "body", m.DataSourceType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DerivedNetworthHistoricalBalance) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DerivedNetworthHistoricalBalance) UnmarshalBinary(b []byte) error {
	var res DerivedNetworthHistoricalBalance
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
