// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ProviderDetail ProviderDetail
// swagger:model ProviderDetail
type ProviderDetail struct {

	// Indicates the priority for which the service is invoked.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul><b>Applicable Values</b><br>
	// * POPULAR: Popular providers.<br>
	// * SUGGESTED: Suggested providers for the user.<br>
	// * COBRAND: Yodlee supported providers.<br>
	// * SEARCH: Providers matching the search text.<br>
	// Read Only: true
	// Enum: [POPULAR SUGGESTED COBRAND SEARCH]
	PRIORITY string `json:"PRIORITY,omitempty"`

	// The authentication type enabled at the provider site. <br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul><b>Applicable Values</b><br>
	// * OAUTH: The site that supports open authentication.<br>
	// * CREDENTIALS: The authentication system of the site expects only credentials like userId, password, customer id, etc.<br>
	// * MFA_CREDENTIALS: Multifactor authentication is implemented at the provider site.<br>
	// Read Only: true
	// Enum: [OAUTH CREDENTIALS MFA_CREDENTIALS]
	AuthType string `json:"authType,omitempty"`

	// The base URL of the provider's site.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
	// Read Only: true
	BaseURL string `json:"baseUrl,omitempty"`

	// Capability of the site<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
	// Read Only: true
	Capability []*Capability `json:"capability"`

	// Country to which the provider belongs.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
	// Read Only: true
	CountryISOCode string `json:"countryISOCode,omitempty"`

	// Logical grouping of dataset attributes into datasets such as Basic Aggregation Data, Account Profile and Documents<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
	// Read Only: true
	Dataset []*ProvidersDataset `json:"dataset"`

	// Favicon link of the provider.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
	// Read Only: true
	Favicon string `json:"favicon,omitempty"`

	// Text to guide user through linking an account that belongs to the site<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
	// Read Only: true
	Help string `json:"help,omitempty"`

	// Unique identifier for the provider site(e.g., financial institution sites, biller sites, lender sites, etc.).<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
	// Read Only: true
	ID int64 `json:"id,omitempty"`

	// Indicates that the site has been added by the user at least once.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
	// Read Only: true
	IsAddedByUser string `json:"isAddedByUser,omitempty"`

	// Indicates if a provider site is auto-refreshed.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
	// Read Only: true
	IsAutoRefreshEnabled *bool `json:"isAutoRefreshEnabled,omitempty"`

	// The language in which the provider details are provided. For example, a site supports two languages English and French. English being the primary language, the provider response will be provided in French depending on the user's locale. The language follows the two letter ISO code.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
	// Read Only: true
	LanguageISOCode string `json:"languageISOCode,omitempty"`

	// Determines when the provider information was updated by Yodlee. If the customer caches the data, the cache is recommended to be refreshed based on this field.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
	// Read Only: true
	LastModified string `json:"lastModified,omitempty"`

	// This entity represents the structure of the login or MFA form that is displayed to the user at the provider site. For performance reasons, this field is returned only when a single provider is requested in the request.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li></ul>
	// Read Only: true
	LoginForm []*LoginForm `json:"loginForm"`

	// The login URL of the provider's site.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
	// Read Only: true
	LoginURL string `json:"loginUrl,omitempty"`

	// The logo link of the provider institution. The link will return the logo in the PNG format.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
	// Read Only: true
	Logo string `json:"logo,omitempty"`

	// The name of a provider site.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
	// Read Only: true
	Name string `json:"name,omitempty"`

	// The primary language of the site.<br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
	// Read Only: true
	PrimaryLanguageISOCode string `json:"primaryLanguageISOCode,omitempty"`

	// Determines if the provider is supported for the cobrand (customer), is in the beta stage, etc. <br><br><b>Endpoints</b>:<ul><li>GET providers/{providerId}</li><li>GET providers</li></ul>
	// Read Only: true
	// Enum: [Supported Beta]
	Status string `json:"status,omitempty"`
}

// Validate validates this provider detail
func (m *ProviderDetail) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePRIORITY(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCapability(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataset(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLoginForm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var providerDetailTypePRIORITYPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["POPULAR","SUGGESTED","COBRAND","SEARCH"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		providerDetailTypePRIORITYPropEnum = append(providerDetailTypePRIORITYPropEnum, v)
	}
}

const (

	// ProviderDetailPRIORITYPOPULAR captures enum value "POPULAR"
	ProviderDetailPRIORITYPOPULAR string = "POPULAR"

	// ProviderDetailPRIORITYSUGGESTED captures enum value "SUGGESTED"
	ProviderDetailPRIORITYSUGGESTED string = "SUGGESTED"

	// ProviderDetailPRIORITYCOBRAND captures enum value "COBRAND"
	ProviderDetailPRIORITYCOBRAND string = "COBRAND"

	// ProviderDetailPRIORITYSEARCH captures enum value "SEARCH"
	ProviderDetailPRIORITYSEARCH string = "SEARCH"
)

// prop value enum
func (m *ProviderDetail) validatePRIORITYEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, providerDetailTypePRIORITYPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProviderDetail) validatePRIORITY(formats strfmt.Registry) error {

	if swag.IsZero(m.PRIORITY) { // not required
		return nil
	}

	// value enum
	if err := m.validatePRIORITYEnum("PRIORITY", "body", m.PRIORITY); err != nil {
		return err
	}

	return nil
}

var providerDetailTypeAuthTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["OAUTH","CREDENTIALS","MFA_CREDENTIALS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		providerDetailTypeAuthTypePropEnum = append(providerDetailTypeAuthTypePropEnum, v)
	}
}

const (

	// ProviderDetailAuthTypeOAUTH captures enum value "OAUTH"
	ProviderDetailAuthTypeOAUTH string = "OAUTH"

	// ProviderDetailAuthTypeCREDENTIALS captures enum value "CREDENTIALS"
	ProviderDetailAuthTypeCREDENTIALS string = "CREDENTIALS"

	// ProviderDetailAuthTypeMFACREDENTIALS captures enum value "MFA_CREDENTIALS"
	ProviderDetailAuthTypeMFACREDENTIALS string = "MFA_CREDENTIALS"
)

// prop value enum
func (m *ProviderDetail) validateAuthTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, providerDetailTypeAuthTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProviderDetail) validateAuthType(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthType) { // not required
		return nil
	}

	// value enum
	if err := m.validateAuthTypeEnum("authType", "body", m.AuthType); err != nil {
		return err
	}

	return nil
}

func (m *ProviderDetail) validateCapability(formats strfmt.Registry) error {

	if swag.IsZero(m.Capability) { // not required
		return nil
	}

	for i := 0; i < len(m.Capability); i++ {
		if swag.IsZero(m.Capability[i]) { // not required
			continue
		}

		if m.Capability[i] != nil {
			if err := m.Capability[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capability" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProviderDetail) validateDataset(formats strfmt.Registry) error {

	if swag.IsZero(m.Dataset) { // not required
		return nil
	}

	for i := 0; i < len(m.Dataset); i++ {
		if swag.IsZero(m.Dataset[i]) { // not required
			continue
		}

		if m.Dataset[i] != nil {
			if err := m.Dataset[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dataset" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProviderDetail) validateLoginForm(formats strfmt.Registry) error {

	if swag.IsZero(m.LoginForm) { // not required
		return nil
	}

	for i := 0; i < len(m.LoginForm); i++ {
		if swag.IsZero(m.LoginForm[i]) { // not required
			continue
		}

		if m.LoginForm[i] != nil {
			if err := m.LoginForm[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("loginForm" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var providerDetailTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Supported","Beta"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		providerDetailTypeStatusPropEnum = append(providerDetailTypeStatusPropEnum, v)
	}
}

const (

	// ProviderDetailStatusSupported captures enum value "Supported"
	ProviderDetailStatusSupported string = "Supported"

	// ProviderDetailStatusBeta captures enum value "Beta"
	ProviderDetailStatusBeta string = "Beta"
)

// prop value enum
func (m *ProviderDetail) validateStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, providerDetailTypeStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProviderDetail) validateStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ProviderDetail) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProviderDetail) UnmarshalBinary(b []byte) error {
	var res ProviderDetail
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
