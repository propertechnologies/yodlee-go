// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DataExtractsAccount DataExtractsAccount
// swagger:model DataExtractsAccount
type DataExtractsAccount struct {

	// The amount borrowed from the 401k account.<br><b>Note</b>: The 401k loan field is only applicable to the 401k account type.<br><b>Applicable containers</b>: investment<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	Nr401kLoan *Money `json:"401kLoan,omitempty"`

	// The type of service. E.g., Bank, Credit Card, Investment, Insurance, etc.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values</b><br>
	// * bank: Applicable for Aggregated and Manual<br>
	// * creditCard: Applicable for Aggregated and Manual<br>
	// * investment: Applicable for Aggregated and Manual<br>
	// * insurance: Applicable for Aggregated and Manual<br>
	// * loan: Applicable for Aggregated and Manual<br>
	// * reward: Applicable for Aggregated and Manual<br>
	// * bill: Applicable for Aggregated and Manual<br>
	// * realEstate: Applicable for Manual<br>
	// * otherAssets: Applicable for Manual<br>
	// * otherLiabilities: Applicable for Manual
	// Read Only: true
	// Enum: [bank creditCard investment insurance loan reward bill realEstate otherAssets otherLiabilities]
	CONTAINER string `json:"CONTAINER,omitempty"`

	// The account name as it appears at the site.<br>(The POST accounts service response return this field as name)<br><b>Applicable containers</b>: All Containers<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	AccountName string `json:"accountName,omitempty"`

	// The account number as it appears on the site. (The POST accounts service response return this field as number)<br><b>Additional Details</b>:<b> Bank/ Loan/ Insurance/ Investment/Bill</b>:<br> The account number for the bank account as it appears at the site.<br><b>Credit Card</b>: The account number of the card account as it appears at the site,<br>i.e., the card number.The account number can be full or partial based on how it is displayed in the account summary page of the site.In most cases, the site does not display the full account number in the account summary page and additional navigation is required to aggregate it.<br><b>Applicable containers</b>: All Containers<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li><li>POST accounts</li></ul>
	// Read Only: true
	AccountNumber string `json:"accountNumber,omitempty"`

	// The status of the account that is updated by the consumer through an application or an API. Valid Values: AccountStatus<br><b>Additional Details:</b><br><b>ACTIVE:</b> All the added manual and aggregated accounts status will be made "ACTIVE" by default. <br><b>TO_BE_CLOSED:</b> If the aggregated accounts are not found or closed in the data provider site, Yodlee system marks the status as TO_BE_CLOSED<br><b>INACTIVE:</b> Users can update the status as INACTIVE to stop updating and to stop considering the account in other services<br><b>CLOSED:</b> Users can update the status as CLOSED, if the account is closed with the provider. <br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values</b><br>
	// * ACTIVE: Active accounts.<br>
	// * INACTIVE: Accounts that are made inactive by the users.<br>
	// * TO_BE_CLOSED: Active accounts.<br>
	// * CLOSED: Accounts that are found to be closed in the provider site and awaiting confirmation from users to get closed.<br>
	// * DELETED: This status is applicable only in case of GET dataExtracts/userData.<br>
	// Read Only: true
	// Enum: [ACTIVE INACTIVE TO_BE_CLOSED CLOSED DELETED]
	AccountStatus string `json:"accountStatus,omitempty"`

	// The type of account that is aggregated, i.e., savings, checking, credit card, charge, HELOC, etc. The account type is derived based on the attributes of the account. <br><b>Valid Values:</b><br><b>Aggregated Account Type</b><br><b>bank</b><ul><li>CHECKING</li><li>SAVINGS</li><li>CD</li><li>PPF</li><li>RECURRING_DEPOSIT</li><li>FSA</li><li>MONEY_MARKET</li><li>IRA</li><li>PREPAID</li></ul><b>creditCard</b><ul><li>OTHER</li><li>CREDIT</li><li>STORE</li><li>CHARGE</li><li>OTHER</li></ul><b>investment (SN 1.0)</b><ul><li>BROKERAGE_MARGIN</li><li>HSA</li><li>IRA</li><li>BROKERAGE_CASH</li><li>401K</li><li>403B</li><li>TRUST</li><li>ANNUITY</li><li>SIMPLE</li><li>CUSTODIAL</li><li>BROKERAGE_CASH_OPTION</li><li>BROKERAGE_MARGIN_OPTION</li><li>INDIVIDUAL</li><li>CORPORATE</li><li>JTTIC</li><li>JTWROS</li><li>COMMUNITY_PROPERTY</li><li>JOINT_BY_ENTIRETY</li><li>CONSERVATORSHIP</li><li>ROTH</li><li>ROTH_CONVERSION</li><li>ROLLOVER</li><li>EDUCATIONAL</li><li>529_PLAN</li><li>457_DEFERRED_COMPENSATION</li><li>401A</li><li>PSP</li><li>MPP</li><li>STOCK_BASKET</li><li>LIVING_TRUST</li><li>REVOCABLE_TRUST</li><li>IRREVOCABLE_TRUST</li><li>CHARITABLE_REMAINDER</li><li>CHARITABLE_LEAD</li><li>CHARITABLE_GIFT_ACCOUNT</li><li>SEP</li><li>UTMA</li><li>UGMA</li><li>ESOPP</li><li>ADMINISTRATOR</li><li>EXECUTOR</li><li>PARTNERSHIP</li><li>SOLE_PROPRIETORSHIP</li><li>CHURCH</li><li>INVESTMENT_CLUB</li><li>RESTRICTED_STOCK_AWARD</li><li>CMA</li><li>EMPLOYEE_STOCK_PURCHASE_PLAN</li><li>PERFORMANCE_PLAN</li><li>BROKERAGE_LINK_ACCOUNT</li><li>MONEY_MARKET</li><li>SUPER_ANNUATION</li><li>REGISTERED_RETIREMENT_SAVINGS_PLAN</li><li>SPOUSAL_RETIREMENT_SAVINGS_PLAN</li><li>DEFERRED_PROFIT_SHARING_PLAN</li><li>NON_REGISTERED_SAVINGS_PLAN</li><li>REGISTERED_EDUCATION_SAVINGS_PLAN</li><li>GROUP_RETIREMENT_SAVINGS_PLAN</li><li>LOCKED_IN_RETIREMENT_SAVINGS_PLAN</li><li>RESTRICTED_LOCKED_IN_SAVINGS_PLAN</li><li>LOCKED_IN_RETIREMENT_ACCOUNT</li><li>REGISTERED_PENSION_PLAN</li><li>TAX_FREE_SAVINGS_ACCOUNT</li><li>LIFE_INCOME_FUND</li><li>REGISTERED_RETIREMENT_INCOME_FUND</li><li>SPOUSAL_RETIREMENT_INCOME_FUND</li><li>LOCKED_IN_REGISTERED_INVESTMENT_FUND</li><li>PRESCRIBED_REGISTERED_RETIREMENT_INCOME_FUND</li><li>GUARANTEED_INVESTMENT_CERTIFICATES</li><li>REGISTERED_DISABILITY_SAVINGS_PLAN</li><li>OTHER</li></ul><b>investment (SN 2.0)</b><ul><li>BROKERAGE_CASH</li><li>BROKERAGE_MARGIN</li><li>INDIVIDUAL_RETIREMENT_ACCOUNT_IRA</li><li>EMPLOYEE_RETIREMENT_ACCOUNT_401K</li><li>EMPLOYEE_RETIREMENT_SAVINGS_PLAN_403B</li><li>TRUST</li><li>ANNUITY</li><li>SIMPLE_IRA</li><li>CUSTODIAL_ACCOUNT</li><li>BROKERAGE_CASH_OPTION</li><li>BROKERAGE_MARGIN_OPTION</li><li>INDIVIDUAL</li><li>CORPORATE_INVESTMENT_ACCOUNT</li><li>JOINT_TENANTS_TENANCY_IN_COMMON_JTIC</li><li>JOINT_TENANTS_WITH_RIGHTS_OF_SURVIVORSHIP_JTWROS</li><li>JOINT_TENANTS_COMMUNITY_PROPERTY</li><li>JOINT_TENANTS_TENANTS_BY_ENTIRETY</li><li>CONSERVATOR</li><li>ROTH_IRA</li><li>ROTH_CONVERSION</li><li>ROLLOVER_IRA</li><li>EDUCATIONAL</li><li>EDUCATIONAL_SAVINGS_PLAN_529</li><li>DEFERRED_COMPENSATION_PLAN_457</li><li>MONEY_PURCHASE_RETIREMENT_PLAN_401A</li><li>PROFIT_SHARING_PLAN</li><li>MONEY_PURCHASE_PLAN</li><li>STOCK_BASKET_ACCOUNT</li><li>LIVING_TRUST</li><li>REVOCABLE_TRUST</li><li>IRREVOCABLE_TRUST</li><li>CHARITABLE_REMAINDER_TRUST</li><li>CHARITABLE_LEAD_TRUST</li><li>CHARITABLE_GIFT_ACCOUNT</li><li>SEP_IRA</li><li>UNIFORM_TRANSFER_TO_MINORS_ACT_UTMA</li><li>UNIFORM_GIFT_TO_MINORS_ACT_UGMA</li><li>EMPLOYEE_STOCK_OWNERSHIP_PLAN_ESOP</li><li>ADMINISTRATOR</li><li>EXECUTOR</li><li>PARTNERSHIP</li><li>PROPRIETORSHIP</li><li>CHURCH_ACCOUNT</li><li>INVESTMENT_CLUB</li><li>RESTRICTED_STOCK_AWARD</li><li>CASH_MANAGEMENT_ACCOUNT</li><li>EMPLOYEE_STOCK_PURCHASE_PLAN_ESPP</li><li>PERFORMANCE_PLAN</li><li>BROKERAGE_LINK_ACCOUNT</li><li>MONEY_MARKET_ACCOUNT</li><li>SUPERANNUATION</li><li>REGISTERED_RETIREMENT_SAVINGS_PLAN_RRSP</li><li>SPOUSAL_RETIREMENT_SAVINGS_PLAN_SRSP</li><li>DEFERRED_PROFIT_SHARING_PLAN_DPSP</li><li>NON_REGISTERED_SAVINGS_PLAN_NRSP</li><li>REGISTERED_EDUCATION_SAVINGS_PLAN_RESP</li><li>GROUP_RETIREMENT_SAVINGS_PLAN_GRSP</li><li>LOCKED_IN_RETIREMENT_SAVINGS_PLAN_LRSP</li><li>RESTRICTED_LOCKED_IN_SAVINGS_PLAN_RLSP</li><li>LOCKED_IN_RETIREMENT_ACCOUNT_LIRA</li><li>REGISTERED_PENSION_PLAN_RPP</li><li>TAX_FREE_SAVINGS_ACCOUNT_TFSA</li><li>LIFE_INCOME_FUND_LIF</li><li>REGISTERED_RETIREMENT_INCOME_FUND_RIF</li><li>SPOUSAL_RETIREMENT_INCOME_FUND_SRIF</li><li>LOCKED_IN_REGISTERED_INVESTMENT_FUND_LRIF</li><li>PRESCRIBED_REGISTERED_RETIREMENT_INCOME_FUND_PRIF</li><li>GUARANTEED_INVESTMENT_CERTIFICATES_GIC</li><li>REGISTERED_DISABILITY_SAVINGS_PLAN_RDSP</li><li>DEFINED_CONTRIBUTION_PLAN</li><li>DEFINED_BENEFIT_PLAN</li><li>EMPLOYEE_STOCK_OPTION_PLAN</li><li>NONQUALIFIED_DEFERRED_COMPENSATION_PLAN_409A</li><li>KEOGH_PLAN</li><li>EMPLOYEE_RETIREMENT_ACCOUNT_ROTH_401K</li><li>DEFERRED_CONTINGENT_CAPITAL_PLAN_DCCP</li><li>EMPLOYEE_BENEFIT_PLAN</li><li>EMPLOYEE_SAVINGS_PLAN</li><li>HEALTH_SAVINGS_ACCOUNT_HSA</li><li>COVERDELL_EDUCATION_SAVINGS_ACCOUNT_ESA</li><li>TESTAMENTARY_TRUST</li><li>ESTATE</li><li>GRANTOR_RETAINED_ANNUITY_TRUST_GRAT</li><li>ADVISORY_ACCOUNT</li><li>NON_PROFIT_ORGANIZATION_501C</li><li>HEALTH_REIMBURSEMENT_ARRANGEMENT_HRA</li><li>INDIVIDUAL_SAVINGS_ACCOUNT_ISA</li><li>CASH_ISA</li><li>STOCKS_AND_SHARES_ISA</li><li>INNOVATIVE_FINANCE_ISA</li><li>JUNIOR_ISA</li><li>EMPLOYEES_PROVIDENT_FUND_ORGANIZATION_EPFO</li><li>PUBLIC_PROVIDENT_FUND_PPF</li><li>EMPLOYEES_PENSION_SCHEME_EPS</li><li>NATIONAL_PENSION_SYSTEM_NPS</li><li>INDEXED_ANNUITY</li><li>ANNUITIZED_ANNUITY</li><li>VARIABLE_ANNUITY</li><li>ROTH_403B</li><li>SPOUSAL_IRA</li><li>SPOUSAL_ROTH_IRA</li><li>SARSEP_IRA</li><li>SUBSTANTIALLY_EQUAL_PERIODIC_PAYMENTS_SEPP</li><li>OFFSHORE_TRUST</li><li>IRREVOCABLE_LIFE_INSURANCE_TRUST</li><li>INTERNATIONAL_TRUST</li><li>LIFE_INTEREST_TRUST</li><li>EMPLOYEE_BENEFIT_TRUST</li><li>PRECIOUS_METAL_ACCOUNT</li><li>INVESTMENT_LOAN_ACCOUNT</li><li>GRANTOR_RETAINED_INCOME_TRUST</li><li>PENSION_PLAN</li><li>OTHER</li></ul><b>bill</b><ul><li>TELEPHONE</li><li>UTILITY</li><li>CABLE</li><li>WIRELESS</li><li>BILLS</li></ul><b>loan</b><ul><li>MORTGAGE</li><li>INSTALLMENT_LOAN</li><li>PERSONAL_LOAN</li><li>HOME_EQUITY_LINE_OF_CREDIT</li><li>LINE_OF_CREDIT</li><li>AUTO_LOAN</li><li>STUDENT_LOAN</li><li>HOME_LOAN</li></ul><b>insurance</b><ul><li>AUTO_INSURANCE</li><li>HEALTH_INSURANCE</li><li>HOME_INSURANCE</li><li>LIFE_INSURANCE</li><li>ANNUITY</li><li>TRAVEL_INSURANCE</li><li>INSURANCE</li></ul><b>realEstate</b><ul> <li>REAL_ESTATE</li></ul><b>reward</b><ul><li>REWARD_POINTS</li></ul><b>Manual Account Type</b><br><b>bank</b><ul><li>CHECKING</li><li>SAVINGS</li><li>CD</li><li>PREPAID</li></ul><b>credit</b><ul>  <li>CREDIT</li></ul><b>loan</b><ul>  <li>PERSONAL_LOAN</li><li>HOME_LOAN</li></ul><b>bill</b><ul><li>BILLS</li></ul><b>insurance</b><ul><li>INSURANCE</li><li>ANNUITY</li></ul><b>investment</b><ul><li>BROKERAGE_CASH</li></ul><br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	AccountType string `json:"accountType,omitempty"`

	// The home address of the real estate account. The address entity for home address consists of state, zip and city only<br><br><b>Aggregated / Manual</b>: Manual<br><b>Applicable containers</b>: realEstate<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	Address *AccountAddress `json:"address,omitempty"`

	// The source through which the account(s) are added in the system.<br><b>Valid Values</b>: SYSTEM, USER<br><b>Applicable containers</b>: All Containers<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values</b><br>
	// * SYSTEM: Accounts that are pre-populated by the customers on behalf of their users in to the Yodlee system.<br>
	// * USER: Accounts that are added by the user.<br>
	// Read Only: true
	// Enum: [SYSTEM USER]
	AggregationSource string `json:"aggregationSource,omitempty"`

	// The amount due to be paid for the account.<br><b>Additional Details:</b><b>Credit Card:</b> The total amount due for the purchase of goods or services that must be paid by the due date.<br><b>Loan:</b> The amount due to be paid on the due date.<br><b>Note:</b> The amount due at the account-level can differ from the amount due at the statement-level, as the information in the aggregated card account data provides more up-to-date information.<br><b>Applicable containers</b>: creditCard, loan, insurance, bill<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	AmountDue *Money `json:"amountDue,omitempty"`

	// Annual percentage yield (APY) is a normalized representation of an interest rate, based on a compounding period of one year. APY generally refers to the rate paid to a depositor by a financial institution on an account.<br><b>Applicable containers</b>: bank<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	AnnualPercentageYield float64 `json:"annualPercentageYield,omitempty"`

	// Indicates the contract value of the annuity.<br><b>Note:</b> The annuity balance field is applicable only to annuities.<br><b>Applicable containers</b>: insurance, investment<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	AnnuityBalance *Money `json:"annuityBalance,omitempty"`

	// The annual percentage rate (APR) is the yearly rate of interest on the credit card account.<br><b>Additional Details:</b> The yearly percentage rate charged when a balance is held on a credit card. This rate of interest is applied every month on the outstanding credit card balance.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: creditCard<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	Apr float64 `json:"apr,omitempty"`

	// The providerAccountIds that share the account with the primary providerAccountId that was created when the user had added the account for the first time.<br><b>Additional Details</b>: This attribute is returned in the response only if the account deduplication feature is enabled and the same account is mapped to more than one provider account IDs indicating the account is owned by more than one user, for example, joint accounts.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: All Containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	AssociatedProviderAccountID []int64 `json:"associatedProviderAccountId"`

	// The balance in the account that is available for spending. For checking accounts with overdraft, available balance may include overdraft amount, if end site adds overdraft balance to available balance.<br><b>Applicable containers</b>: bank, investment<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br>GET accounts/{accountId}
	// Read Only: true
	AvailableBalance *Money `json:"availableBalance,omitempty"`

	// The amount that is available for an ATM withdrawal, i.e., the cash available after deducting the amount that is already withdrawn from the total cash limit. (totalCashLimit-cashAdvance= availableCash)<br><b>Additional Details:</b> The available cash amount at the account-level can differ from the available cash at the statement-level, as the information in the aggregated card account data provides more up-to-date information.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: creditCard<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	AvailableCash *Money `json:"availableCash,omitempty"`

	// <br><b>Credit Card:</b> Amount that is available to spend on the credit card. It is usually the Total credit line- Running balance- pending charges. <br><b>Loan:</b> The unused portion of  line of credit, on a revolving loan (such as a home-equity line of credit).<br><b>Additional Details:</b><br><b>Note:</b> The available credit amount at the account-level can differ from the available credit field at the statement-level, as the information in the aggregated card account data provides more up-to-date information.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: creditCard, loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	AvailableCredit *Money `json:"availableCredit,omitempty"`

	// The total account value. <br><b>Additional Details:</b><br><b>Bank:</b> available balance or current balance.<br><b>Credit Card:</b> running Balance.<br><b>Investment:</b> The total balance of all the investment account, as it appears on the FI site.<br><b>Insurance:</b> CashValue or amountDue<br><b>Loan:</b> principalBalance<br><b>Bill:</b> amountDue<br><b>Applicable containers</b>: bank, creditCard, investment, insurance, loan, bill, otherAssets, otherLiabilities, realEstate<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	Balance *Money `json:"balance,omitempty"`

	// Bank and branch identification information.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, investment, loan<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	BankTransferCode []*BankTransferCode `json:"bankTransferCode"`

	// The amount that is available for immediate withdrawal or the total amount available to purchase securities in a brokerage or investment account.<br><b>Note:</b> The cash balance field is only applicable to brokerage related accounts.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	Cash *Money `json:"cash,omitempty"`

	// The APR applicable to cash withdrawals on the credit card account.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: creditCard<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	CashAPR float64 `json:"cashAPR,omitempty"`

	// The amount of cash value available in the consumer's life insurance policy account - except for term insurance policy - for withdrawals, loans, etc. This field is also used to capture the cash value on the home insurance policy.It is the standard that the insurance company generally prefer to reimburse the policyholder for his or her loss, i.e., the cash value is equal to the replacement cost minus depreciation. The cash value is also referred to as surrender value in India for life insurance policies.<br><b>Note:</b> The cash value field is applicable to all types of life insurance (except for term life) and home insurance.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	CashValue *Money `json:"cashValue,omitempty"`

	// The classification of the account such as personal, corporate, etc.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, creditCard, investment, reward, loan, insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values</b><br>
	// * OTHER: Other account.<br>
	// * PERSONAL: Personal account.<br>
	// * CORPORATE: Corporate account.<br>
	// * SMALL_BUSINESS: Small business account.<br>
	// * TRUST: Trust account.<br>
	// * ADD_ON_CARD: Add on card account.<br>
	// * VIRTUAL_CARD: Virtual card account.<br>
	// Read Only: true
	// Enum: [OTHER PERSONAL CORPORATE SMALL_BUSINESS TRUST ADD_ON_CARD VIRTUAL_CARD]
	Classification string `json:"classification,omitempty"`

	// Property or possession offered to support a loan that can be seized on a default.<br><b>Applicable containers</b>: loan<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	Collateral string `json:"collateral,omitempty"`

	// The coverage-related details of the account.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance,investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	Coverage []*Coverage `json:"coverage"`

	// The date on which the account is created in the Yodlee system.<br><b>Additional Details:</b> It is the date when the user links or aggregates the account(s) that are held with the provider to the Yodlee system.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	CreatedDate string `json:"createdDate,omitempty"`

	// The balance in the account that is available at the beginning of the business day; it is equal to the ledger balance of the account.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	CurrentBalance *Money `json:"currentBalance,omitempty"`

	// Current level of the reward program the user is associated with. E.g. Silver, Jade etc.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	CurrentLevel string `json:"currentLevel,omitempty"`

	// Logical grouping of dataset attributes into datasets such as Basic Aggregation Data, Account Profile and Documents.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	Dataset []*AccountDataset `json:"dataset"`

	// The death benefit amount on a life insurance policy and annuity. It is usually equal to the face amount of the policy, but sometimes can vary for a whole life and universal life insurance policies.<br><b>Note:</b> The death benefit amount field is applicable only to annuities and life insurance.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	DeathBenefit *Money `json:"deathBenefit,omitempty"`

	// The name or identification of the account owner, as it appears at the FI site. <br><b>Note:</b> The account holder name can be full or partial based on how it is displayed in the account summary page of the FI site. In most cases, the FI site does not display the full account holder name in the account summary page.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, creditCard, investment, insurance, loan, bill, reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	DisplayedName string `json:"displayedName,omitempty"`

	// The date on which the due amount has to be paid. <br><b>Additional Details:</b><br><b>Credit Card:</b> The monthly date by when the minimum payment is due to be paid on the credit card account. <br><b>Loan:</b> The date on or before which the due amount should be paid.<br><b>Note:</b> The due date at the account-level can differ from the due date field at the statement-level, as the information in the aggregated card account data provides an up-to-date information to the consumer.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: creditCard, loan, insurance, bill<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	DueDate string `json:"dueDate,omitempty"`

	// Date on which the user is enrolled on the rewards program.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	EnrollmentDate string `json:"enrollmentDate,omitempty"`

	// The amount a mortgage company holds to pay a consumer's non-mortgage related expenses like insurance and property taxes. <br><b>Additional Details:</b><br><b>Note:</b> The escrow balance field is only applicable to the mortgage account type.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	EscrowBalance *Money `json:"escrowBalance,omitempty"`

	// The date on which the home value was estimated.<br><br><b>Aggregated / Manual</b>: Manual<br><b>Applicable containers</b>: realEstate<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	EstimatedDate string `json:"estimatedDate,omitempty"`

	// The date on which the insurance policy expires or matures.<br><b>Additional Details:</b> The due date at the account-level can differ from the due date field at the statement-level, as the information in the aggregated card account data provides an up-to-date information to the consumer.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	ExpirationDate string `json:"expirationDate,omitempty"`

	// The amount stated on the face of a consumer's policy that will be paid in the event of his or her death or any other event as stated in the insurance policy. The face amount is also referred to as the sum insured or maturity value in India.<br><b>Note:</b> The face amount field is applicable only to life insurance.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	FaceAmount *Money `json:"faceAmount,omitempty"`

	// The frequency of the billing cycle of the account in case of card and bills. The frequency in which premiums are paid in an insurance policy such as monthly, quarterly, and annually. The frequency in which due amounts are paid in a loan  account.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: bill, creditCard, insurance, loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values</b><br>
	// * DAILY: Occurs every day.<br>
	// * ONE_TIME: Occurs once.<br>
	// * WEEKLY: Occurs once in a week.<br>
	// * EVERY_2_WEEKS: Occurs once in two weeks.<br>
	// * SEMI_MONTHLY: Occurs once in 15 days.<br>
	// * MONTHLY: Occurs once in a month.<br>
	// * QUARTERLY: Occurs once in three months.<br>
	// * SEMI_ANNUALLY: Occurs once in six months.<br>
	// * ANNUALLY: Occurs once in a year.<br>
	// * EVERY_2_MONTHS: Occurs once in two months.<br>
	// * OTHER: <br>
	// * FIRST_DAY_MONTHLY: Occurs on first day of every month.<br>
	// * LAST_DAY_MONTHLY: Occurs on last day of every month.<br>
	// * EVERY_4_WEEKS: Occurs once in four weeks.<br>
	// Read Only: true
	// Enum: [DAILY ONE_TIME WEEKLY EVERY_2_WEEKS SEMI_MONTHLY MONTHLY QUARTERLY SEMI_ANNUALLY ANNUALLY EVERY_2_MONTHS OTHER FIRST_DAY_MONTHLY LAST_DAY_MONTHLY EVERY_4_WEEKS]
	Frequency string `json:"frequency,omitempty"`

	// A nonprofit or state organization that works with lender, servicer, school, and the Department of Education to help successfully repay Federal Family Education Loan Program (FFELP) loans. If FFELP student loans default, the guarantor takes ownership of them.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	Guarantor string `json:"guarantor,omitempty"`

	// Type of home insurance, like -<ul><li>HOME_OWNER</li><li>RENTAL</li><li>RENTER</li><li>etc..</li></ul><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values</b><br>
	// * HOME_OWNER: Home owner insurance policy for the house.<br>
	// * RENTAL: Rental insurance is the insurance taken by the owner for the house when it is being rented out.<br>
	// * RENTER: Renters insurance is for occupants who do not own the property but want to protect their personal belongings that are in the home.<br>
	// * UNKNOWN: The unknown type of home insurance policy.<br>
	// * OTHER: The home insurance policy other than what has been listed here.<br>
	// Read Only: true
	// Enum: [HOME_OWNER RENTAL RENTER UNKNOWN OTHER]
	HomeInsuranceType string `json:"homeInsuranceType,omitempty"`

	// The home value of the real estate account.<br><br><b>Aggregated / Manual</b>: Manual<br><b>Applicable containers</b>: realEstate<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	HomeValue *Money `json:"homeValue,omitempty"`

	// The primary key of the account resource and the unique identifier for the account.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts </li><li>GET accounts/{accountId}</li><li>GET investmentOptions</li><li>GET accounts/historicalBalances</li><li>POST accounts</ul>
	// Read Only: true
	ID int64 `json:"id,omitempty"`

	// Used to determine  whether an account to be considered in the networth calculation.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank,creditCard,loan,investment,insurance,realEstate,otherAssets,otherLiabilities<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	IncludeInNetWorth *bool `json:"includeInNetWorth,omitempty"`

	// Interest paid in last calendar year.<br><b>Applicable containers</b>: loan<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	InterestPaidLastYear *Money `json:"interestPaidLastYear,omitempty"`

	// Interest paid from the start of the year to date.<br><b>Applicable containers</b>: loan<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	InterestPaidYTD *Money `json:"interestPaidYTD,omitempty"`

	// <br><b>Bank:</b> The interest rate offered by a FI to its depositors on a bank account.<br><b>Loan:</b> Interest rate applied on the loan.<br><b>Additional Details:</b><br><b>Note:</b> The Interest Rate field is only applicable for the following account types: savings, checking, money market, and certificate of deposit.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	InterestRate float64 `json:"interestRate,omitempty"`

	// The type of the interest rate, for example, fixed or variable.<br><b>Applicable containers</b>: loan<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values</b><br>
	// * FIXED: Fixed interest rate.<br>
	// * VARIABLE: Variable intererest rate.<br>
	// * UNKNOWN: Unknown<br>
	// * OTHER: Other<br>
	// Read Only: true
	// Enum: [FIXED VARIABLE UNKNOWN OTHER]
	InterestRateType string `json:"interestRateType,omitempty"`

	// The account to be considered as an asset or liability.<br><b>Applicable containers</b>: All Containers<br><b>Aggregated / Manual</b>: Both <br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	IsAsset *bool `json:"isAsset,omitempty"`

	// Indicates if an account is aggregated from a site or it is a manual account i.e. account information manually provided by the user.<br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	IsManual *bool `json:"isManual,omitempty"`

	// Indicates the last amount contributed by the employee to the 401k account.<br><b>Note:</b> The last employee contribution amount field is derived from the transaction data and not aggregated from the FI site. The field is only applicable to the 401k account type.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	LastEmployeeContributionAmount *Money `json:"lastEmployeeContributionAmount,omitempty"`

	// The date on which the last employee contribution was made to the 401k account.<br><b>Note:</b> The last employee contribution date field is derived from the transaction data and not aggregated from the FI site. The field is only applicable to the 401k account type.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	LastEmployeeContributionDate string `json:"lastEmployeeContributionDate,omitempty"`

	// The last payment made for the account.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bill<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	LastPayment *Money `json:"lastPayment,omitempty"`

	// Last/Previous payment amount on the account.  Portion of the principal and interest paid on previous month or period to satisfy a loan.<br><b>Additional Details:</b> If the payment is already done for the current billing cycle, then the field indicates the payment of the current billing cycle. If payment is yet to be done for the current billing cycle, then the field indicates the payment that was made for any of the previous billing cycles.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: creditCard, loan, insurance, bill<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	LastPaymentAmount *Money `json:"lastPaymentAmount,omitempty"`

	// The date on which the payment for the previous or current billing cycle is done.<br><b>Additional Details:</b> If the payment is already done for the current billing cycle, then the field indicates the payment date of the current billing cycle. If payment is yet to be done for the current billing cycle, then the field indicates the date on which the payment was made for any of the previous billing cycles. The last payment date at the account-level can differ from the last payment date at the statement-level, as the information in the aggregated card account data provides an up-to-date information to the consumer.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: creditCard, loan, insurance, bill<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	LastPaymentDate string `json:"lastPaymentDate,omitempty"`

	// The date time the account information was last retrieved from the provider site and updated in the Yodlee system.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	LastUpdated string `json:"lastUpdated,omitempty"`

	// The financial institution that provides the loan.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	Lender string `json:"lender,omitempty"`

	// Type of life insurance.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values</b><br>
	// * OTHER: Other type of insurances.<br>
	// * TERM_LIFE_INSURANCE: Term insurance, a type of life insurance, provides coverage for a certain period of time or years. If the insured dies over the policy tenure a death benefit (or sum assured) is paid out. No payout is made if the insured survives the tenure.<br>
	// * UNIVERSAL_LIFE_INSURANCE: Universal life insurance (often shortened to UL) is a type of cash value life insurance, sold primarily in the United States of America. Under the terms of the policy, the excess of premium payments above the current cost of insurance is credited to the cash value of the policy.<br>
	// * WHOLE_LIFE_INSURANCE: Life insurance policy which is guaranteed to remain in force for the insured's entire lifetime, provided required premiums are paid, or to the maturity date.<br>
	// * VARIABLE_LIFE_INSURANCE: Variable life insurance is a permanent life insurance policy with an investment component.<br>
	// * ULIP: ULIP is a life insurance product, which provides risk cover for the policy holder along with investment options to invest in any number of qualified investments such as stocks, bonds or mutual funds.<br>
	// * ENDOWMENT: An endowment policy is a life insurance contract designed to pay a lump sum after a specific term (on its 'maturity') or on death.<br>
	// Read Only: true
	// Enum: [OTHER TERM_LIFE_INSURANCE UNIVERSAL_LIFE_INSURANCE WHOLE_LIFE_INSURANCE VARIABLE_LIFE_INSURANCE ULIP ENDOWMENT]
	LifeInsuranceType string `json:"lifeInsuranceType,omitempty"`

	// The date by which the payoff amount should be paid.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	LoanPayByDate string `json:"loanPayByDate,omitempty"`

	// The loan payoff details such as date by which the payoff amount should be paid, loan payoff amount, and the outstanding balance on the loan account.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	LoanPayOffDetails *LoanPayoffDetails `json:"loanPayOffDetails,omitempty"`

	// The amount to be paid to close the loan account, i.e., the total amount required to meet a borrower's obligation on a loan.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	LoanPayoffAmount *Money `json:"loanPayoffAmount,omitempty"`

	// The amount of borrowed funds used to purchase securities.<br><b>Note</b>: Margin balance is displayed only if the brokerage account is approved for margin. The margin balance field is only applicable to brokerage related accounts.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	MarginBalance *Money `json:"marginBalance,omitempty"`

	// The maturity amount on the CD is the amount(principal and interest) paid on or after the maturity date.<br><b>Additional Details:</b> The Maturity Amount field is only applicable for the account type CD(Fixed Deposits).<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	MaturityAmount *Money `json:"maturityAmount,omitempty"`

	// The date when a certificate of deposit (CD/FD) matures or the final payment date of a loan at which point the principal amount (including pending interest) is due to be paid.<br><b>Additional Details:</b> The date when a certificate of deposit (CD) matures, i.e., the money in the CD can be withdrawn without paying an early withdrawal penalty.The final payment date of a loan, i.e., the principal amount (including pending interest) is due to be paid.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	MaturityDate string `json:"maturityDate,omitempty"`

	// The additional description or notes given by the user.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	Memo string `json:"memo,omitempty"`

	// The minimum amount due is the lowest amount of money that a consumer is required to pay each month.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: creditCard, insurance, bill, loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	MinimumAmountDue *Money `json:"minimumAmountDue,omitempty"`

	// The amount in the money market fund or its equivalent such as bank deposit programs.<br><b>Note:</b> The money market balance field is only applicable to brokerage related accounts.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	MoneyMarketBalance *Money `json:"moneyMarketBalance,omitempty"`

	// The eligible next level of the rewards program.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	NextLevel string `json:"nextLevel,omitempty"`

	// The nickname of the account as provided by the consumer to identify an account. The account nickname can be used instead of the account name.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	Nickname string `json:"nickname,omitempty"`

	// The amount of loan that the lender has provided.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	OriginalLoanAmount *Money `json:"originalLoanAmount,omitempty"`

	// The date on which the loan is disbursed.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	OriginationDate string `json:"originationDate,omitempty"`

	// The overdraft Limit for the account.<br><b>Note:</b> The overdraft Limit is provided only for AUS, INDIA, UK, NZ locales.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	OverDraftLimit *Money `json:"overDraftLimit,omitempty"`

	// The date on which the insurance policy coverage commences.<br><b>Applicable containers</b>: insurance<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	PolicyEffectiveDate string `json:"policyEffectiveDate,omitempty"`

	// The date the insurance policy began.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	PolicyFromDate string `json:"policyFromDate,omitempty"`

	// The status of the policy.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values</b><br>
	// * ACTIVE: Denotes the policy is active.<br>
	// * INACTIVE: Denotes the policy is inactive.<br>
	// * OTHER: The status could not be determined or it is other than active/inactive.<br>
	// Read Only: true
	// Enum: [ACTIVE INACTIVE OTHER]
	PolicyStatus string `json:"policyStatus,omitempty"`

	// The duration for which the policy is valid or in effect. For example, one year, five years, etc.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	PolicyTerm string `json:"policyTerm,omitempty"`

	// The date to which the policy exists.<br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	PolicyToDate string `json:"policyToDate,omitempty"`

	// The financial cost that the policyholder pays to the insurance company to obtain an insurance cover.The premium is paid as a lump sum or in installments during the duration of the policy.<br><b>Applicable containers</b>: insurance<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	Premium *Money `json:"premium,omitempty"`

	// The number of years for which premium payments have to be made in a policy.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	PremiumPaymentTerm string `json:"premiumPaymentTerm,omitempty"`

	// Primary reward unit for this reward program. E.g. miles, points, etc.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	PrimaryRewardUnit string `json:"primaryRewardUnit,omitempty"`

	// The principal or loan balance is the outstanding balance on a loan account, excluding the interest and fees. The principal balance is the original borrowed amount plus any applicable loan fees, minus any principal payments.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	PrincipalBalance *Money `json:"principalBalance,omitempty"`

	// The primary key of the provider account resource.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	ProviderAccountID int64 `json:"providerAccountId,omitempty"`

	// Identifier of the provider site. The primary key of provider resource. <br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	ProviderID string `json:"providerId,omitempty"`

	// Service provider or institution name where the account originates. This belongs to the provider resource.<br><br><b>Aggregated / Manual</b>: Both <br><b>Applicable containers</b>: All containers<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	ProviderName string `json:"providerName,omitempty"`

	// The monthly or periodic payment on a loan that is recurring in nature. The recurring payment amount is usually same as the amount due, unless late fees or other charges are added eventually changing the amount due for a particular month.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	RecurringPayment *Money `json:"recurringPayment,omitempty"`

	// The sum of the future payments due to be paid to the insurance company during a policy year. It is the policy rate minus the payments made till date.<br><b>Note:</b> The remaining balance field is applicable only to auto insurance and home insurance.<br><b>Applicable containers</b>: insurance<br><b>Aggregated / Manual</b>: Aggregated<br><b>Endpoints</b>:<br><ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	RemainingBalance *Money `json:"remainingBalance,omitempty"`

	// The type of repayment plan that the borrower prefers to repay the loan. <br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values:</b><br>
	// * STANDARD: A 10-year payment plan where the borrower makes the same fixed payments every month.<br>
	// * GRADUATED: A 10-year payment plan where the monthly payments start small and increase every two years.<br>
	// * EXTENDED: A payment plan with low monthly payments and an extended repayment term of up to 25 years. The borrower can either choose fixed monthly payments or graduated payments that increase over time.<br>
	// Read Only: true
	// Enum: [STANDARD GRADUATED EXTENDED]
	RepaymentPlanType string `json:"repaymentPlanType,omitempty"`

	// Information of different reward balances associated with the account.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: reward<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	RewardBalance []*RewardBalance `json:"rewardBalance"`

	// The amount that is currently owed on the credit card account.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: creditCard<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	RunningBalance *Money `json:"runningBalance,omitempty"`

	// The sum of the current market values of short positions held in a brokerage account.<br><b>Note:</b> The short balance balance field is only applicable to brokerage related accounts.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	ShortBalance *Money `json:"shortBalance,omitempty"`

	// Indicates the status of the loan account. <br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values:</b><br>
	// * IN_REPAYMENT: The borrower is currently repaying the student loan.<br>
	// * DEFAULTED: The borrower has failed to repay the loan according to the terms of the promissory note.<br>
	// * IN_SCHOOL: Indicates the borrower is still in school.<br>
	// * IN_GRACE_PERIOD: The specified period (usually six months) between the date student graduates or drops below half time status and the date the loan repayment begins.<br>
	// * DELINQUENCY: The borrower has failed to make loan repayments when due. Delinquency begins with the first missed loan repayment.<br>
	// * DEFERMENT: A period when the student postpones the loan repayments.<br>
	// Read Only: true
	// Enum: [IN_REPAYMENT DEFAULTED IN_SCHOOL IN_GRACE_PERIOD DELINQUENCY DEFERMENT]
	SourceAccountStatus string `json:"sourceAccountStatus,omitempty"`

	// The tenure for which the CD account is valid  or in case of loan, the number of years/months over which the loan amount  has to be repaid. <br><b>Additional Details:</b><br>  Bank: The Term field is only applicable for the account type CD.Loan: The period for which the loan agreement is in force. The period, before or at the end of which, the loan should either be repaid or renegotiated for another term.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: bank, loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	Term string `json:"term,omitempty"`

	// The maximum amount that can be withdrawn from an ATM using the credit card. Credit cards issuer allow cardholders to withdraw cash using their cards - the cash limit is a percent of the overall credit limit.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: creditCard<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	TotalCashLimit *Money `json:"totalCashLimit,omitempty"`

	// The maximum amount of credit a financial institution extends to a consumer through a line of credit or a revolving loan like HELOC. <br><b>Additional Details:</b><br><b>Note:</b> The credit limit field is applicable only to LOC and HELOC account types.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: loan<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	TotalCreditLimit *Money `json:"totalCreditLimit,omitempty"`

	// Total credit line is the amount of money that can be charged to a credit card. If credit limit of $5,000 is issued on a credit card, the total charges on the card cannot exceed this amount.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: creditCard<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	TotalCreditLine *Money `json:"totalCreditLine,omitempty"`

	// The total unvested balance that appears in an investment account.Such as the 401k account or the equity award account that includes employer provided funding. <br><b>Note:</b> The amount the employer contributes is generally subject to vesting and remain unvested for a specific period of time or until fulfillment of certain conditions. The total unvested balance field is only applicable to the retirement related accounts such as 401k, equity awards, etc.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	TotalUnvestedBalance *Money `json:"totalUnvestedBalance,omitempty"`

	// The total vested balance that appears in an investment account. Such as the 401k account or the equity award account that includes employer provided funding. <br><b>Note:</b> The amount an employee can claim after he or she leaves the organization. The total vested balance field is only applicable to the retirement related accounts such as 401k, equity awards, etc.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	TotalVestedBalance *Money `json:"totalVestedBalance,omitempty"`

	// <b>Applicable containers</b>: reward, bank, creditCard, investment, loan, insurance, realEstate, bill, otherLiabilities<br><b>Endpoints</b>:<ul><li>GET accounts </li><li>GET accounts/{accountId}</li><li>POST accounts</ul><b>Applicable Values</b><br>
	// * BUSINESS: Indicates a small business account.<br>
	// * PERSONAL: Indicates a personal account.<br>
	// Read Only: true
	// Enum: [BUSINESS PERSONAL]
	UserClassification string `json:"userClassification,omitempty"`

	// The valuation Type indicates whether the home value is calculated either manually or by Yodlee Partners.<br><br><b>Aggregated / Manual</b>: Manual<br><b>Applicable containers</b>: realEstate<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values</b><br>
	// * SYSTEM: Home value provided by the system.<br>
	// * MANUAL: Home value manually provided by the user.<br>
	// Read Only: true
	// Enum: [SYSTEM MANUAL]
	ValuationType string `json:"valuationType,omitempty"`
}

// Validate validates this data extracts account
func (m *DataExtractsAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNr401kLoan(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCONTAINER(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccountStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAggregationSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAmountDue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAnnuityBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableCash(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableCredit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBankTransferCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCash(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCashValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClassification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCoverage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrentBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataset(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeathBenefit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEscrowBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFaceAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrequency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHomeInsuranceType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHomeValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInterestPaidLastYear(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInterestPaidYTD(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInterestRateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastEmployeeContributionAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastPayment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastPaymentAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLifeInsuranceType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLoanPayOffDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLoanPayoffAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMarginBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaturityAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMinimumAmountDue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMoneyMarketBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginalLoanAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOverDraftLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicyStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePremium(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrincipalBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecurringPayment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemainingBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRepaymentPlanType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRewardBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRunningBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShortBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceAccountStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalCashLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalCreditLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalCreditLine(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalUnvestedBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalVestedBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserClassification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValuationType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataExtractsAccount) validateNr401kLoan(formats strfmt.Registry) error {

	if swag.IsZero(m.Nr401kLoan) { // not required
		return nil
	}

	if m.Nr401kLoan != nil {
		if err := m.Nr401kLoan.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("401kLoan")
			}
			return err
		}
	}

	return nil
}

var dataExtractsAccountTypeCONTAINERPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["bank","creditCard","investment","insurance","loan","reward","bill","realEstate","otherAssets","otherLiabilities"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataExtractsAccountTypeCONTAINERPropEnum = append(dataExtractsAccountTypeCONTAINERPropEnum, v)
	}
}

const (

	// DataExtractsAccountCONTAINERBank captures enum value "bank"
	DataExtractsAccountCONTAINERBank string = "bank"

	// DataExtractsAccountCONTAINERCreditCard captures enum value "creditCard"
	DataExtractsAccountCONTAINERCreditCard string = "creditCard"

	// DataExtractsAccountCONTAINERInvestment captures enum value "investment"
	DataExtractsAccountCONTAINERInvestment string = "investment"

	// DataExtractsAccountCONTAINERInsurance captures enum value "insurance"
	DataExtractsAccountCONTAINERInsurance string = "insurance"

	// DataExtractsAccountCONTAINERLoan captures enum value "loan"
	DataExtractsAccountCONTAINERLoan string = "loan"

	// DataExtractsAccountCONTAINERReward captures enum value "reward"
	DataExtractsAccountCONTAINERReward string = "reward"

	// DataExtractsAccountCONTAINERBill captures enum value "bill"
	DataExtractsAccountCONTAINERBill string = "bill"

	// DataExtractsAccountCONTAINERRealEstate captures enum value "realEstate"
	DataExtractsAccountCONTAINERRealEstate string = "realEstate"

	// DataExtractsAccountCONTAINEROtherAssets captures enum value "otherAssets"
	DataExtractsAccountCONTAINEROtherAssets string = "otherAssets"

	// DataExtractsAccountCONTAINEROtherLiabilities captures enum value "otherLiabilities"
	DataExtractsAccountCONTAINEROtherLiabilities string = "otherLiabilities"
)

// prop value enum
func (m *DataExtractsAccount) validateCONTAINEREnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataExtractsAccountTypeCONTAINERPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataExtractsAccount) validateCONTAINER(formats strfmt.Registry) error {

	if swag.IsZero(m.CONTAINER) { // not required
		return nil
	}

	// value enum
	if err := m.validateCONTAINEREnum("CONTAINER", "body", m.CONTAINER); err != nil {
		return err
	}

	return nil
}

var dataExtractsAccountTypeAccountStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ACTIVE","INACTIVE","TO_BE_CLOSED","CLOSED","DELETED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataExtractsAccountTypeAccountStatusPropEnum = append(dataExtractsAccountTypeAccountStatusPropEnum, v)
	}
}

const (

	// DataExtractsAccountAccountStatusACTIVE captures enum value "ACTIVE"
	DataExtractsAccountAccountStatusACTIVE string = "ACTIVE"

	// DataExtractsAccountAccountStatusINACTIVE captures enum value "INACTIVE"
	DataExtractsAccountAccountStatusINACTIVE string = "INACTIVE"

	// DataExtractsAccountAccountStatusTOBECLOSED captures enum value "TO_BE_CLOSED"
	DataExtractsAccountAccountStatusTOBECLOSED string = "TO_BE_CLOSED"

	// DataExtractsAccountAccountStatusCLOSED captures enum value "CLOSED"
	DataExtractsAccountAccountStatusCLOSED string = "CLOSED"

	// DataExtractsAccountAccountStatusDELETED captures enum value "DELETED"
	DataExtractsAccountAccountStatusDELETED string = "DELETED"
)

// prop value enum
func (m *DataExtractsAccount) validateAccountStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataExtractsAccountTypeAccountStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataExtractsAccount) validateAccountStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.AccountStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateAccountStatusEnum("accountStatus", "body", m.AccountStatus); err != nil {
		return err
	}

	return nil
}

func (m *DataExtractsAccount) validateAddress(formats strfmt.Registry) error {

	if swag.IsZero(m.Address) { // not required
		return nil
	}

	if m.Address != nil {
		if err := m.Address.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("address")
			}
			return err
		}
	}

	return nil
}

var dataExtractsAccountTypeAggregationSourcePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SYSTEM","USER"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataExtractsAccountTypeAggregationSourcePropEnum = append(dataExtractsAccountTypeAggregationSourcePropEnum, v)
	}
}

const (

	// DataExtractsAccountAggregationSourceSYSTEM captures enum value "SYSTEM"
	DataExtractsAccountAggregationSourceSYSTEM string = "SYSTEM"

	// DataExtractsAccountAggregationSourceUSER captures enum value "USER"
	DataExtractsAccountAggregationSourceUSER string = "USER"
)

// prop value enum
func (m *DataExtractsAccount) validateAggregationSourceEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataExtractsAccountTypeAggregationSourcePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataExtractsAccount) validateAggregationSource(formats strfmt.Registry) error {

	if swag.IsZero(m.AggregationSource) { // not required
		return nil
	}

	// value enum
	if err := m.validateAggregationSourceEnum("aggregationSource", "body", m.AggregationSource); err != nil {
		return err
	}

	return nil
}

func (m *DataExtractsAccount) validateAmountDue(formats strfmt.Registry) error {

	if swag.IsZero(m.AmountDue) { // not required
		return nil
	}

	if m.AmountDue != nil {
		if err := m.AmountDue.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("amountDue")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateAnnuityBalance(formats strfmt.Registry) error {

	if swag.IsZero(m.AnnuityBalance) { // not required
		return nil
	}

	if m.AnnuityBalance != nil {
		if err := m.AnnuityBalance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("annuityBalance")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateAvailableBalance(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableBalance) { // not required
		return nil
	}

	if m.AvailableBalance != nil {
		if err := m.AvailableBalance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("availableBalance")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateAvailableCash(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableCash) { // not required
		return nil
	}

	if m.AvailableCash != nil {
		if err := m.AvailableCash.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("availableCash")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateAvailableCredit(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableCredit) { // not required
		return nil
	}

	if m.AvailableCredit != nil {
		if err := m.AvailableCredit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("availableCredit")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateBalance(formats strfmt.Registry) error {

	if swag.IsZero(m.Balance) { // not required
		return nil
	}

	if m.Balance != nil {
		if err := m.Balance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("balance")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateBankTransferCode(formats strfmt.Registry) error {

	if swag.IsZero(m.BankTransferCode) { // not required
		return nil
	}

	for i := 0; i < len(m.BankTransferCode); i++ {
		if swag.IsZero(m.BankTransferCode[i]) { // not required
			continue
		}

		if m.BankTransferCode[i] != nil {
			if err := m.BankTransferCode[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("bankTransferCode" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataExtractsAccount) validateCash(formats strfmt.Registry) error {

	if swag.IsZero(m.Cash) { // not required
		return nil
	}

	if m.Cash != nil {
		if err := m.Cash.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cash")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateCashValue(formats strfmt.Registry) error {

	if swag.IsZero(m.CashValue) { // not required
		return nil
	}

	if m.CashValue != nil {
		if err := m.CashValue.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cashValue")
			}
			return err
		}
	}

	return nil
}

var dataExtractsAccountTypeClassificationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["OTHER","PERSONAL","CORPORATE","SMALL_BUSINESS","TRUST","ADD_ON_CARD","VIRTUAL_CARD"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataExtractsAccountTypeClassificationPropEnum = append(dataExtractsAccountTypeClassificationPropEnum, v)
	}
}

const (

	// DataExtractsAccountClassificationOTHER captures enum value "OTHER"
	DataExtractsAccountClassificationOTHER string = "OTHER"

	// DataExtractsAccountClassificationPERSONAL captures enum value "PERSONAL"
	DataExtractsAccountClassificationPERSONAL string = "PERSONAL"

	// DataExtractsAccountClassificationCORPORATE captures enum value "CORPORATE"
	DataExtractsAccountClassificationCORPORATE string = "CORPORATE"

	// DataExtractsAccountClassificationSMALLBUSINESS captures enum value "SMALL_BUSINESS"
	DataExtractsAccountClassificationSMALLBUSINESS string = "SMALL_BUSINESS"

	// DataExtractsAccountClassificationTRUST captures enum value "TRUST"
	DataExtractsAccountClassificationTRUST string = "TRUST"

	// DataExtractsAccountClassificationADDONCARD captures enum value "ADD_ON_CARD"
	DataExtractsAccountClassificationADDONCARD string = "ADD_ON_CARD"

	// DataExtractsAccountClassificationVIRTUALCARD captures enum value "VIRTUAL_CARD"
	DataExtractsAccountClassificationVIRTUALCARD string = "VIRTUAL_CARD"
)

// prop value enum
func (m *DataExtractsAccount) validateClassificationEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataExtractsAccountTypeClassificationPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataExtractsAccount) validateClassification(formats strfmt.Registry) error {

	if swag.IsZero(m.Classification) { // not required
		return nil
	}

	// value enum
	if err := m.validateClassificationEnum("classification", "body", m.Classification); err != nil {
		return err
	}

	return nil
}

func (m *DataExtractsAccount) validateCoverage(formats strfmt.Registry) error {

	if swag.IsZero(m.Coverage) { // not required
		return nil
	}

	for i := 0; i < len(m.Coverage); i++ {
		if swag.IsZero(m.Coverage[i]) { // not required
			continue
		}

		if m.Coverage[i] != nil {
			if err := m.Coverage[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("coverage" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataExtractsAccount) validateCurrentBalance(formats strfmt.Registry) error {

	if swag.IsZero(m.CurrentBalance) { // not required
		return nil
	}

	if m.CurrentBalance != nil {
		if err := m.CurrentBalance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("currentBalance")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateDataset(formats strfmt.Registry) error {

	if swag.IsZero(m.Dataset) { // not required
		return nil
	}

	for i := 0; i < len(m.Dataset); i++ {
		if swag.IsZero(m.Dataset[i]) { // not required
			continue
		}

		if m.Dataset[i] != nil {
			if err := m.Dataset[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dataset" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataExtractsAccount) validateDeathBenefit(formats strfmt.Registry) error {

	if swag.IsZero(m.DeathBenefit) { // not required
		return nil
	}

	if m.DeathBenefit != nil {
		if err := m.DeathBenefit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("deathBenefit")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateEscrowBalance(formats strfmt.Registry) error {

	if swag.IsZero(m.EscrowBalance) { // not required
		return nil
	}

	if m.EscrowBalance != nil {
		if err := m.EscrowBalance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("escrowBalance")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateFaceAmount(formats strfmt.Registry) error {

	if swag.IsZero(m.FaceAmount) { // not required
		return nil
	}

	if m.FaceAmount != nil {
		if err := m.FaceAmount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("faceAmount")
			}
			return err
		}
	}

	return nil
}

var dataExtractsAccountTypeFrequencyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DAILY","ONE_TIME","WEEKLY","EVERY_2_WEEKS","SEMI_MONTHLY","MONTHLY","QUARTERLY","SEMI_ANNUALLY","ANNUALLY","EVERY_2_MONTHS","OTHER","FIRST_DAY_MONTHLY","LAST_DAY_MONTHLY","EVERY_4_WEEKS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataExtractsAccountTypeFrequencyPropEnum = append(dataExtractsAccountTypeFrequencyPropEnum, v)
	}
}

const (

	// DataExtractsAccountFrequencyDAILY captures enum value "DAILY"
	DataExtractsAccountFrequencyDAILY string = "DAILY"

	// DataExtractsAccountFrequencyONETIME captures enum value "ONE_TIME"
	DataExtractsAccountFrequencyONETIME string = "ONE_TIME"

	// DataExtractsAccountFrequencyWEEKLY captures enum value "WEEKLY"
	DataExtractsAccountFrequencyWEEKLY string = "WEEKLY"

	// DataExtractsAccountFrequencyEVERY2WEEKS captures enum value "EVERY_2_WEEKS"
	DataExtractsAccountFrequencyEVERY2WEEKS string = "EVERY_2_WEEKS"

	// DataExtractsAccountFrequencySEMIMONTHLY captures enum value "SEMI_MONTHLY"
	DataExtractsAccountFrequencySEMIMONTHLY string = "SEMI_MONTHLY"

	// DataExtractsAccountFrequencyMONTHLY captures enum value "MONTHLY"
	DataExtractsAccountFrequencyMONTHLY string = "MONTHLY"

	// DataExtractsAccountFrequencyQUARTERLY captures enum value "QUARTERLY"
	DataExtractsAccountFrequencyQUARTERLY string = "QUARTERLY"

	// DataExtractsAccountFrequencySEMIANNUALLY captures enum value "SEMI_ANNUALLY"
	DataExtractsAccountFrequencySEMIANNUALLY string = "SEMI_ANNUALLY"

	// DataExtractsAccountFrequencyANNUALLY captures enum value "ANNUALLY"
	DataExtractsAccountFrequencyANNUALLY string = "ANNUALLY"

	// DataExtractsAccountFrequencyEVERY2MONTHS captures enum value "EVERY_2_MONTHS"
	DataExtractsAccountFrequencyEVERY2MONTHS string = "EVERY_2_MONTHS"

	// DataExtractsAccountFrequencyOTHER captures enum value "OTHER"
	DataExtractsAccountFrequencyOTHER string = "OTHER"

	// DataExtractsAccountFrequencyFIRSTDAYMONTHLY captures enum value "FIRST_DAY_MONTHLY"
	DataExtractsAccountFrequencyFIRSTDAYMONTHLY string = "FIRST_DAY_MONTHLY"

	// DataExtractsAccountFrequencyLASTDAYMONTHLY captures enum value "LAST_DAY_MONTHLY"
	DataExtractsAccountFrequencyLASTDAYMONTHLY string = "LAST_DAY_MONTHLY"

	// DataExtractsAccountFrequencyEVERY4WEEKS captures enum value "EVERY_4_WEEKS"
	DataExtractsAccountFrequencyEVERY4WEEKS string = "EVERY_4_WEEKS"
)

// prop value enum
func (m *DataExtractsAccount) validateFrequencyEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataExtractsAccountTypeFrequencyPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataExtractsAccount) validateFrequency(formats strfmt.Registry) error {

	if swag.IsZero(m.Frequency) { // not required
		return nil
	}

	// value enum
	if err := m.validateFrequencyEnum("frequency", "body", m.Frequency); err != nil {
		return err
	}

	return nil
}

var dataExtractsAccountTypeHomeInsuranceTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["HOME_OWNER","RENTAL","RENTER","UNKNOWN","OTHER"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataExtractsAccountTypeHomeInsuranceTypePropEnum = append(dataExtractsAccountTypeHomeInsuranceTypePropEnum, v)
	}
}

const (

	// DataExtractsAccountHomeInsuranceTypeHOMEOWNER captures enum value "HOME_OWNER"
	DataExtractsAccountHomeInsuranceTypeHOMEOWNER string = "HOME_OWNER"

	// DataExtractsAccountHomeInsuranceTypeRENTAL captures enum value "RENTAL"
	DataExtractsAccountHomeInsuranceTypeRENTAL string = "RENTAL"

	// DataExtractsAccountHomeInsuranceTypeRENTER captures enum value "RENTER"
	DataExtractsAccountHomeInsuranceTypeRENTER string = "RENTER"

	// DataExtractsAccountHomeInsuranceTypeUNKNOWN captures enum value "UNKNOWN"
	DataExtractsAccountHomeInsuranceTypeUNKNOWN string = "UNKNOWN"

	// DataExtractsAccountHomeInsuranceTypeOTHER captures enum value "OTHER"
	DataExtractsAccountHomeInsuranceTypeOTHER string = "OTHER"
)

// prop value enum
func (m *DataExtractsAccount) validateHomeInsuranceTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataExtractsAccountTypeHomeInsuranceTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataExtractsAccount) validateHomeInsuranceType(formats strfmt.Registry) error {

	if swag.IsZero(m.HomeInsuranceType) { // not required
		return nil
	}

	// value enum
	if err := m.validateHomeInsuranceTypeEnum("homeInsuranceType", "body", m.HomeInsuranceType); err != nil {
		return err
	}

	return nil
}

func (m *DataExtractsAccount) validateHomeValue(formats strfmt.Registry) error {

	if swag.IsZero(m.HomeValue) { // not required
		return nil
	}

	if m.HomeValue != nil {
		if err := m.HomeValue.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("homeValue")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateInterestPaidLastYear(formats strfmt.Registry) error {

	if swag.IsZero(m.InterestPaidLastYear) { // not required
		return nil
	}

	if m.InterestPaidLastYear != nil {
		if err := m.InterestPaidLastYear.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("interestPaidLastYear")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateInterestPaidYTD(formats strfmt.Registry) error {

	if swag.IsZero(m.InterestPaidYTD) { // not required
		return nil
	}

	if m.InterestPaidYTD != nil {
		if err := m.InterestPaidYTD.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("interestPaidYTD")
			}
			return err
		}
	}

	return nil
}

var dataExtractsAccountTypeInterestRateTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["FIXED","VARIABLE","UNKNOWN","OTHER"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataExtractsAccountTypeInterestRateTypePropEnum = append(dataExtractsAccountTypeInterestRateTypePropEnum, v)
	}
}

const (

	// DataExtractsAccountInterestRateTypeFIXED captures enum value "FIXED"
	DataExtractsAccountInterestRateTypeFIXED string = "FIXED"

	// DataExtractsAccountInterestRateTypeVARIABLE captures enum value "VARIABLE"
	DataExtractsAccountInterestRateTypeVARIABLE string = "VARIABLE"

	// DataExtractsAccountInterestRateTypeUNKNOWN captures enum value "UNKNOWN"
	DataExtractsAccountInterestRateTypeUNKNOWN string = "UNKNOWN"

	// DataExtractsAccountInterestRateTypeOTHER captures enum value "OTHER"
	DataExtractsAccountInterestRateTypeOTHER string = "OTHER"
)

// prop value enum
func (m *DataExtractsAccount) validateInterestRateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataExtractsAccountTypeInterestRateTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataExtractsAccount) validateInterestRateType(formats strfmt.Registry) error {

	if swag.IsZero(m.InterestRateType) { // not required
		return nil
	}

	// value enum
	if err := m.validateInterestRateTypeEnum("interestRateType", "body", m.InterestRateType); err != nil {
		return err
	}

	return nil
}

func (m *DataExtractsAccount) validateLastEmployeeContributionAmount(formats strfmt.Registry) error {

	if swag.IsZero(m.LastEmployeeContributionAmount) { // not required
		return nil
	}

	if m.LastEmployeeContributionAmount != nil {
		if err := m.LastEmployeeContributionAmount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lastEmployeeContributionAmount")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateLastPayment(formats strfmt.Registry) error {

	if swag.IsZero(m.LastPayment) { // not required
		return nil
	}

	if m.LastPayment != nil {
		if err := m.LastPayment.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lastPayment")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateLastPaymentAmount(formats strfmt.Registry) error {

	if swag.IsZero(m.LastPaymentAmount) { // not required
		return nil
	}

	if m.LastPaymentAmount != nil {
		if err := m.LastPaymentAmount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lastPaymentAmount")
			}
			return err
		}
	}

	return nil
}

var dataExtractsAccountTypeLifeInsuranceTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["OTHER","TERM_LIFE_INSURANCE","UNIVERSAL_LIFE_INSURANCE","WHOLE_LIFE_INSURANCE","VARIABLE_LIFE_INSURANCE","ULIP","ENDOWMENT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataExtractsAccountTypeLifeInsuranceTypePropEnum = append(dataExtractsAccountTypeLifeInsuranceTypePropEnum, v)
	}
}

const (

	// DataExtractsAccountLifeInsuranceTypeOTHER captures enum value "OTHER"
	DataExtractsAccountLifeInsuranceTypeOTHER string = "OTHER"

	// DataExtractsAccountLifeInsuranceTypeTERMLIFEINSURANCE captures enum value "TERM_LIFE_INSURANCE"
	DataExtractsAccountLifeInsuranceTypeTERMLIFEINSURANCE string = "TERM_LIFE_INSURANCE"

	// DataExtractsAccountLifeInsuranceTypeUNIVERSALLIFEINSURANCE captures enum value "UNIVERSAL_LIFE_INSURANCE"
	DataExtractsAccountLifeInsuranceTypeUNIVERSALLIFEINSURANCE string = "UNIVERSAL_LIFE_INSURANCE"

	// DataExtractsAccountLifeInsuranceTypeWHOLELIFEINSURANCE captures enum value "WHOLE_LIFE_INSURANCE"
	DataExtractsAccountLifeInsuranceTypeWHOLELIFEINSURANCE string = "WHOLE_LIFE_INSURANCE"

	// DataExtractsAccountLifeInsuranceTypeVARIABLELIFEINSURANCE captures enum value "VARIABLE_LIFE_INSURANCE"
	DataExtractsAccountLifeInsuranceTypeVARIABLELIFEINSURANCE string = "VARIABLE_LIFE_INSURANCE"

	// DataExtractsAccountLifeInsuranceTypeULIP captures enum value "ULIP"
	DataExtractsAccountLifeInsuranceTypeULIP string = "ULIP"

	// DataExtractsAccountLifeInsuranceTypeENDOWMENT captures enum value "ENDOWMENT"
	DataExtractsAccountLifeInsuranceTypeENDOWMENT string = "ENDOWMENT"
)

// prop value enum
func (m *DataExtractsAccount) validateLifeInsuranceTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataExtractsAccountTypeLifeInsuranceTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataExtractsAccount) validateLifeInsuranceType(formats strfmt.Registry) error {

	if swag.IsZero(m.LifeInsuranceType) { // not required
		return nil
	}

	// value enum
	if err := m.validateLifeInsuranceTypeEnum("lifeInsuranceType", "body", m.LifeInsuranceType); err != nil {
		return err
	}

	return nil
}

func (m *DataExtractsAccount) validateLoanPayOffDetails(formats strfmt.Registry) error {

	if swag.IsZero(m.LoanPayOffDetails) { // not required
		return nil
	}

	if m.LoanPayOffDetails != nil {
		if err := m.LoanPayOffDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("loanPayOffDetails")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateLoanPayoffAmount(formats strfmt.Registry) error {

	if swag.IsZero(m.LoanPayoffAmount) { // not required
		return nil
	}

	if m.LoanPayoffAmount != nil {
		if err := m.LoanPayoffAmount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("loanPayoffAmount")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateMarginBalance(formats strfmt.Registry) error {

	if swag.IsZero(m.MarginBalance) { // not required
		return nil
	}

	if m.MarginBalance != nil {
		if err := m.MarginBalance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("marginBalance")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateMaturityAmount(formats strfmt.Registry) error {

	if swag.IsZero(m.MaturityAmount) { // not required
		return nil
	}

	if m.MaturityAmount != nil {
		if err := m.MaturityAmount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("maturityAmount")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateMinimumAmountDue(formats strfmt.Registry) error {

	if swag.IsZero(m.MinimumAmountDue) { // not required
		return nil
	}

	if m.MinimumAmountDue != nil {
		if err := m.MinimumAmountDue.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("minimumAmountDue")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateMoneyMarketBalance(formats strfmt.Registry) error {

	if swag.IsZero(m.MoneyMarketBalance) { // not required
		return nil
	}

	if m.MoneyMarketBalance != nil {
		if err := m.MoneyMarketBalance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("moneyMarketBalance")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateOriginalLoanAmount(formats strfmt.Registry) error {

	if swag.IsZero(m.OriginalLoanAmount) { // not required
		return nil
	}

	if m.OriginalLoanAmount != nil {
		if err := m.OriginalLoanAmount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originalLoanAmount")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateOverDraftLimit(formats strfmt.Registry) error {

	if swag.IsZero(m.OverDraftLimit) { // not required
		return nil
	}

	if m.OverDraftLimit != nil {
		if err := m.OverDraftLimit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("overDraftLimit")
			}
			return err
		}
	}

	return nil
}

var dataExtractsAccountTypePolicyStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ACTIVE","INACTIVE","OTHER"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataExtractsAccountTypePolicyStatusPropEnum = append(dataExtractsAccountTypePolicyStatusPropEnum, v)
	}
}

const (

	// DataExtractsAccountPolicyStatusACTIVE captures enum value "ACTIVE"
	DataExtractsAccountPolicyStatusACTIVE string = "ACTIVE"

	// DataExtractsAccountPolicyStatusINACTIVE captures enum value "INACTIVE"
	DataExtractsAccountPolicyStatusINACTIVE string = "INACTIVE"

	// DataExtractsAccountPolicyStatusOTHER captures enum value "OTHER"
	DataExtractsAccountPolicyStatusOTHER string = "OTHER"
)

// prop value enum
func (m *DataExtractsAccount) validatePolicyStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataExtractsAccountTypePolicyStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataExtractsAccount) validatePolicyStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.PolicyStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validatePolicyStatusEnum("policyStatus", "body", m.PolicyStatus); err != nil {
		return err
	}

	return nil
}

func (m *DataExtractsAccount) validatePremium(formats strfmt.Registry) error {

	if swag.IsZero(m.Premium) { // not required
		return nil
	}

	if m.Premium != nil {
		if err := m.Premium.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("premium")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validatePrincipalBalance(formats strfmt.Registry) error {

	if swag.IsZero(m.PrincipalBalance) { // not required
		return nil
	}

	if m.PrincipalBalance != nil {
		if err := m.PrincipalBalance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("principalBalance")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateRecurringPayment(formats strfmt.Registry) error {

	if swag.IsZero(m.RecurringPayment) { // not required
		return nil
	}

	if m.RecurringPayment != nil {
		if err := m.RecurringPayment.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recurringPayment")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateRemainingBalance(formats strfmt.Registry) error {

	if swag.IsZero(m.RemainingBalance) { // not required
		return nil
	}

	if m.RemainingBalance != nil {
		if err := m.RemainingBalance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remainingBalance")
			}
			return err
		}
	}

	return nil
}

var dataExtractsAccountTypeRepaymentPlanTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["STANDARD","GRADUATED","EXTENDED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataExtractsAccountTypeRepaymentPlanTypePropEnum = append(dataExtractsAccountTypeRepaymentPlanTypePropEnum, v)
	}
}

const (

	// DataExtractsAccountRepaymentPlanTypeSTANDARD captures enum value "STANDARD"
	DataExtractsAccountRepaymentPlanTypeSTANDARD string = "STANDARD"

	// DataExtractsAccountRepaymentPlanTypeGRADUATED captures enum value "GRADUATED"
	DataExtractsAccountRepaymentPlanTypeGRADUATED string = "GRADUATED"

	// DataExtractsAccountRepaymentPlanTypeEXTENDED captures enum value "EXTENDED"
	DataExtractsAccountRepaymentPlanTypeEXTENDED string = "EXTENDED"
)

// prop value enum
func (m *DataExtractsAccount) validateRepaymentPlanTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataExtractsAccountTypeRepaymentPlanTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataExtractsAccount) validateRepaymentPlanType(formats strfmt.Registry) error {

	if swag.IsZero(m.RepaymentPlanType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRepaymentPlanTypeEnum("repaymentPlanType", "body", m.RepaymentPlanType); err != nil {
		return err
	}

	return nil
}

func (m *DataExtractsAccount) validateRewardBalance(formats strfmt.Registry) error {

	if swag.IsZero(m.RewardBalance) { // not required
		return nil
	}

	for i := 0; i < len(m.RewardBalance); i++ {
		if swag.IsZero(m.RewardBalance[i]) { // not required
			continue
		}

		if m.RewardBalance[i] != nil {
			if err := m.RewardBalance[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rewardBalance" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataExtractsAccount) validateRunningBalance(formats strfmt.Registry) error {

	if swag.IsZero(m.RunningBalance) { // not required
		return nil
	}

	if m.RunningBalance != nil {
		if err := m.RunningBalance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("runningBalance")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateShortBalance(formats strfmt.Registry) error {

	if swag.IsZero(m.ShortBalance) { // not required
		return nil
	}

	if m.ShortBalance != nil {
		if err := m.ShortBalance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shortBalance")
			}
			return err
		}
	}

	return nil
}

var dataExtractsAccountTypeSourceAccountStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["IN_REPAYMENT","DEFAULTED","IN_SCHOOL","IN_GRACE_PERIOD","DELINQUENCY","DEFERMENT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataExtractsAccountTypeSourceAccountStatusPropEnum = append(dataExtractsAccountTypeSourceAccountStatusPropEnum, v)
	}
}

const (

	// DataExtractsAccountSourceAccountStatusINREPAYMENT captures enum value "IN_REPAYMENT"
	DataExtractsAccountSourceAccountStatusINREPAYMENT string = "IN_REPAYMENT"

	// DataExtractsAccountSourceAccountStatusDEFAULTED captures enum value "DEFAULTED"
	DataExtractsAccountSourceAccountStatusDEFAULTED string = "DEFAULTED"

	// DataExtractsAccountSourceAccountStatusINSCHOOL captures enum value "IN_SCHOOL"
	DataExtractsAccountSourceAccountStatusINSCHOOL string = "IN_SCHOOL"

	// DataExtractsAccountSourceAccountStatusINGRACEPERIOD captures enum value "IN_GRACE_PERIOD"
	DataExtractsAccountSourceAccountStatusINGRACEPERIOD string = "IN_GRACE_PERIOD"

	// DataExtractsAccountSourceAccountStatusDELINQUENCY captures enum value "DELINQUENCY"
	DataExtractsAccountSourceAccountStatusDELINQUENCY string = "DELINQUENCY"

	// DataExtractsAccountSourceAccountStatusDEFERMENT captures enum value "DEFERMENT"
	DataExtractsAccountSourceAccountStatusDEFERMENT string = "DEFERMENT"
)

// prop value enum
func (m *DataExtractsAccount) validateSourceAccountStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataExtractsAccountTypeSourceAccountStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataExtractsAccount) validateSourceAccountStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.SourceAccountStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateSourceAccountStatusEnum("sourceAccountStatus", "body", m.SourceAccountStatus); err != nil {
		return err
	}

	return nil
}

func (m *DataExtractsAccount) validateTotalCashLimit(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalCashLimit) { // not required
		return nil
	}

	if m.TotalCashLimit != nil {
		if err := m.TotalCashLimit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("totalCashLimit")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateTotalCreditLimit(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalCreditLimit) { // not required
		return nil
	}

	if m.TotalCreditLimit != nil {
		if err := m.TotalCreditLimit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("totalCreditLimit")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateTotalCreditLine(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalCreditLine) { // not required
		return nil
	}

	if m.TotalCreditLine != nil {
		if err := m.TotalCreditLine.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("totalCreditLine")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateTotalUnvestedBalance(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalUnvestedBalance) { // not required
		return nil
	}

	if m.TotalUnvestedBalance != nil {
		if err := m.TotalUnvestedBalance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("totalUnvestedBalance")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsAccount) validateTotalVestedBalance(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalVestedBalance) { // not required
		return nil
	}

	if m.TotalVestedBalance != nil {
		if err := m.TotalVestedBalance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("totalVestedBalance")
			}
			return err
		}
	}

	return nil
}

var dataExtractsAccountTypeUserClassificationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BUSINESS","PERSONAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataExtractsAccountTypeUserClassificationPropEnum = append(dataExtractsAccountTypeUserClassificationPropEnum, v)
	}
}

const (

	// DataExtractsAccountUserClassificationBUSINESS captures enum value "BUSINESS"
	DataExtractsAccountUserClassificationBUSINESS string = "BUSINESS"

	// DataExtractsAccountUserClassificationPERSONAL captures enum value "PERSONAL"
	DataExtractsAccountUserClassificationPERSONAL string = "PERSONAL"
)

// prop value enum
func (m *DataExtractsAccount) validateUserClassificationEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataExtractsAccountTypeUserClassificationPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataExtractsAccount) validateUserClassification(formats strfmt.Registry) error {

	if swag.IsZero(m.UserClassification) { // not required
		return nil
	}

	// value enum
	if err := m.validateUserClassificationEnum("userClassification", "body", m.UserClassification); err != nil {
		return err
	}

	return nil
}

var dataExtractsAccountTypeValuationTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SYSTEM","MANUAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataExtractsAccountTypeValuationTypePropEnum = append(dataExtractsAccountTypeValuationTypePropEnum, v)
	}
}

const (

	// DataExtractsAccountValuationTypeSYSTEM captures enum value "SYSTEM"
	DataExtractsAccountValuationTypeSYSTEM string = "SYSTEM"

	// DataExtractsAccountValuationTypeMANUAL captures enum value "MANUAL"
	DataExtractsAccountValuationTypeMANUAL string = "MANUAL"
)

// prop value enum
func (m *DataExtractsAccount) validateValuationTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataExtractsAccountTypeValuationTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataExtractsAccount) validateValuationType(formats strfmt.Registry) error {

	if swag.IsZero(m.ValuationType) { // not required
		return nil
	}

	// value enum
	if err := m.validateValuationTypeEnum("valuationType", "body", m.ValuationType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataExtractsAccount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataExtractsAccount) UnmarshalBinary(b []byte) error {
	var res DataExtractsAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
