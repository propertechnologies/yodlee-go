// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UpdateVerification UpdateVerification
// swagger:model UpdateVerification
type UpdateVerification struct {

	// account
	Account *VerificationAccount `json:"account,omitempty"`

	// Unique identifier for the account.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
	AccountID int64 `json:"accountId,omitempty"`

	// Unique identifier for the provider account.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
	ProviderAccountID int64 `json:"providerAccountId,omitempty"`

	// The reason the account verification failed.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
	// * DATA_NOT_AVAILABLE: <br><b>Description: </b>The account holder's name related details are not available at the FI site.
	// * ACCOUNT_HOLDER_MISMATCH: <br><b>Description: </b>The account verification process has failed due to account holder's data mismatch
	// * FULL_ACCOUNT_NUMBER_AND_BANK_TRANSFER_CODE_NOT_AVAILABLE: <br><b>Description: </b>The account verification process has failed as the full account number and bank transfer code are not available.
	// * FULL_ACCOUNT_NUMBER_NOT_AVAILABLE: <br><b>Description: </b>The account verification process has failed as the full account number is not available.
	// * BANK_TRANSFER_CODE_NOT_AVAILABLE: <br><b>Description: </b>The account verification process has failed as the bank transfer code is not available.
	// * EXPIRED: <br><b>Description: </b>The time limit to verify the microtransaction details has expired.
	// * DATA_MISMATCH: <br><b>Description: </b>The account verification process has failed due to data mismatch.
	// * INSTRUCTION_GENERATION_ERROR: <br><b>Description: </b>The consumer's account verification has failed.
	// Read Only: true
	// Enum: [DATA_NOT_AVAILABLE ACCOUNT_HOLDER_MISMATCH FULL_ACCOUNT_NUMBER_AND_BANK_TRANSFER_CODE_NOT_AVAILABLE FULL_ACCOUNT_NUMBER_NOT_AVAILABLE BANK_TRANSFER_CODE_NOT_AVAILABLE EXPIRED DATA_MISMATCH INSTRUCTION_GENERATION_ERROR]
	Reason string `json:"reason,omitempty"`

	// transaction
	Transaction []*VerificationTransaction `json:"transaction"`

	// The date of the account verification.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
	// Read Only: true
	VerificationDate string `json:"verificationDate,omitempty"`

	// Unique identifier for the verification request.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul>
	// Read Only: true
	VerificationID int64 `json:"verificationId,omitempty"`

	// The status of the account verification.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul><br><b>Applicable Values</b>
	// * INITIATED: <br><b>Description: </b>The account verification process is initiated.<br>
	// * DEPOSITED: <br><b>Description: </b>The microdeposits and debits for the CDV process are posted to the consumer's account.<br>
	// * SUCCESS: <br><b>Description: </b>The consumer's account verification is successful.<br>
	// * FAILED: <br><b>Description: </b>Due to technical issues Yodlee could not post the microtransactions in the user's account.<br>
	// Read Only: true
	// Enum: [INITIATED DEPOSITED SUCCESS FAILED]
	VerificationStatus string `json:"verificationStatus,omitempty"`

	// The account verification type.<br><br><b>Endpoints</b>:<ul><li>POST verification</li><li>GET verification</li><li>PUT verification</li></ul><br><b>Applicable Values</b>
	// Enum: [MATCHING CHALLENGE_DEPOSIT]
	VerificationType string `json:"verificationType,omitempty"`
}

// Validate validates this update verification
func (m *UpdateVerification) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReason(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransaction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVerificationStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVerificationType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UpdateVerification) validateAccount(formats strfmt.Registry) error {

	if swag.IsZero(m.Account) { // not required
		return nil
	}

	if m.Account != nil {
		if err := m.Account.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("account")
			}
			return err
		}
	}

	return nil
}

var updateVerificationTypeReasonPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DATA_NOT_AVAILABLE","ACCOUNT_HOLDER_MISMATCH","FULL_ACCOUNT_NUMBER_AND_BANK_TRANSFER_CODE_NOT_AVAILABLE","FULL_ACCOUNT_NUMBER_NOT_AVAILABLE","BANK_TRANSFER_CODE_NOT_AVAILABLE","EXPIRED","DATA_MISMATCH","INSTRUCTION_GENERATION_ERROR"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateVerificationTypeReasonPropEnum = append(updateVerificationTypeReasonPropEnum, v)
	}
}

const (

	// UpdateVerificationReasonDATANOTAVAILABLE captures enum value "DATA_NOT_AVAILABLE"
	UpdateVerificationReasonDATANOTAVAILABLE string = "DATA_NOT_AVAILABLE"

	// UpdateVerificationReasonACCOUNTHOLDERMISMATCH captures enum value "ACCOUNT_HOLDER_MISMATCH"
	UpdateVerificationReasonACCOUNTHOLDERMISMATCH string = "ACCOUNT_HOLDER_MISMATCH"

	// UpdateVerificationReasonFULLACCOUNTNUMBERANDBANKTRANSFERCODENOTAVAILABLE captures enum value "FULL_ACCOUNT_NUMBER_AND_BANK_TRANSFER_CODE_NOT_AVAILABLE"
	UpdateVerificationReasonFULLACCOUNTNUMBERANDBANKTRANSFERCODENOTAVAILABLE string = "FULL_ACCOUNT_NUMBER_AND_BANK_TRANSFER_CODE_NOT_AVAILABLE"

	// UpdateVerificationReasonFULLACCOUNTNUMBERNOTAVAILABLE captures enum value "FULL_ACCOUNT_NUMBER_NOT_AVAILABLE"
	UpdateVerificationReasonFULLACCOUNTNUMBERNOTAVAILABLE string = "FULL_ACCOUNT_NUMBER_NOT_AVAILABLE"

	// UpdateVerificationReasonBANKTRANSFERCODENOTAVAILABLE captures enum value "BANK_TRANSFER_CODE_NOT_AVAILABLE"
	UpdateVerificationReasonBANKTRANSFERCODENOTAVAILABLE string = "BANK_TRANSFER_CODE_NOT_AVAILABLE"

	// UpdateVerificationReasonEXPIRED captures enum value "EXPIRED"
	UpdateVerificationReasonEXPIRED string = "EXPIRED"

	// UpdateVerificationReasonDATAMISMATCH captures enum value "DATA_MISMATCH"
	UpdateVerificationReasonDATAMISMATCH string = "DATA_MISMATCH"

	// UpdateVerificationReasonINSTRUCTIONGENERATIONERROR captures enum value "INSTRUCTION_GENERATION_ERROR"
	UpdateVerificationReasonINSTRUCTIONGENERATIONERROR string = "INSTRUCTION_GENERATION_ERROR"
)

// prop value enum
func (m *UpdateVerification) validateReasonEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, updateVerificationTypeReasonPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *UpdateVerification) validateReason(formats strfmt.Registry) error {

	if swag.IsZero(m.Reason) { // not required
		return nil
	}

	// value enum
	if err := m.validateReasonEnum("reason", "body", m.Reason); err != nil {
		return err
	}

	return nil
}

func (m *UpdateVerification) validateTransaction(formats strfmt.Registry) error {

	if swag.IsZero(m.Transaction) { // not required
		return nil
	}

	for i := 0; i < len(m.Transaction); i++ {
		if swag.IsZero(m.Transaction[i]) { // not required
			continue
		}

		if m.Transaction[i] != nil {
			if err := m.Transaction[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("transaction" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var updateVerificationTypeVerificationStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["INITIATED","DEPOSITED","SUCCESS","FAILED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateVerificationTypeVerificationStatusPropEnum = append(updateVerificationTypeVerificationStatusPropEnum, v)
	}
}

const (

	// UpdateVerificationVerificationStatusINITIATED captures enum value "INITIATED"
	UpdateVerificationVerificationStatusINITIATED string = "INITIATED"

	// UpdateVerificationVerificationStatusDEPOSITED captures enum value "DEPOSITED"
	UpdateVerificationVerificationStatusDEPOSITED string = "DEPOSITED"

	// UpdateVerificationVerificationStatusSUCCESS captures enum value "SUCCESS"
	UpdateVerificationVerificationStatusSUCCESS string = "SUCCESS"

	// UpdateVerificationVerificationStatusFAILED captures enum value "FAILED"
	UpdateVerificationVerificationStatusFAILED string = "FAILED"
)

// prop value enum
func (m *UpdateVerification) validateVerificationStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, updateVerificationTypeVerificationStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *UpdateVerification) validateVerificationStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.VerificationStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateVerificationStatusEnum("verificationStatus", "body", m.VerificationStatus); err != nil {
		return err
	}

	return nil
}

var updateVerificationTypeVerificationTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["MATCHING","CHALLENGE_DEPOSIT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateVerificationTypeVerificationTypePropEnum = append(updateVerificationTypeVerificationTypePropEnum, v)
	}
}

const (

	// UpdateVerificationVerificationTypeMATCHING captures enum value "MATCHING"
	UpdateVerificationVerificationTypeMATCHING string = "MATCHING"

	// UpdateVerificationVerificationTypeCHALLENGEDEPOSIT captures enum value "CHALLENGE_DEPOSIT"
	UpdateVerificationVerificationTypeCHALLENGEDEPOSIT string = "CHALLENGE_DEPOSIT"
)

// prop value enum
func (m *UpdateVerification) validateVerificationTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, updateVerificationTypeVerificationTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *UpdateVerification) validateVerificationType(formats strfmt.Registry) error {

	if swag.IsZero(m.VerificationType) { // not required
		return nil
	}

	// value enum
	if err := m.validateVerificationTypeEnum("verificationType", "body", m.VerificationType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *UpdateVerification) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UpdateVerification) UnmarshalBinary(b []byte) error {
	var res UpdateVerification
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
