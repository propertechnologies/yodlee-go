// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// Statement Statement
// swagger:model Statement
type Statement struct {

	// Account to which the statement belongs to.<br><br><b>Applicable containers</b>: creditCard, bill, loan, insurance<br>
	// Read Only: true
	AccountID int64 `json:"accountId,omitempty"`

	// The total amount owed at the end of the billing period.<br><br><b>Applicable containers</b>: creditCard, bill, loan, insurance<br>
	// Read Only: true
	AmountDue *Money `json:"amountDue,omitempty"`

	// The APR applied to the balance on the credit card account, as available in the statement.<br><b>Note:</b> In case of variable APR, the APR available on the statement might differ from the APR available at the account-level.<br><br><b>Applicable containers</b>: creditCard, bill, loan, insurance<br>
	// Read Only: true
	Apr float64 `json:"apr,omitempty"`

	// The end date of the statement period.<br><br><b>Applicable containers</b>: creditCard, bill, loan, insurance<br>
	// Read Only: true
	BillingPeriodEnd string `json:"billingPeriodEnd,omitempty"`

	// The start date of the statement period.<br><br><b>Applicable containers</b>: creditCard, bill, loan, insurance<br>
	// Read Only: true
	BillingPeriodStart string `json:"billingPeriodStart,omitempty"`

	// Cash Advance is the amount that is withdrawn from credit card over the counter or from an ATM up to the available credit/cash limit.<br><br><b>Applicable containers</b>: creditCard, bill, loan, insurance<br>
	// Read Only: true
	CashAdvance *Money `json:"cashAdvance,omitempty"`

	// The APR applicable to cash withdrawals on the credit card account.<br><br><b>Applicable containers</b>: creditCard, bill, loan, insurance<br>
	// Read Only: true
	CashApr float64 `json:"cashApr,omitempty"`

	// The date by when the minimum payment is due to be paid.<br><b>Note:</b> The due date that appears in the statement may differ from the due date at the account-level.<br><br><b>Applicable containers</b>: creditCard, bill, loan, insurance<br>
	// Read Only: true
	DueDate string `json:"dueDate,omitempty"`

	// Unique identifier for the statement.<br><br><b>Applicable containers</b>: creditCard, bill, loan, insurance<br>
	// Read Only: true
	ID int64 `json:"id,omitempty"`

	// The interest amount that is part of the amount due or the payment amount.<br><br><b>Applicable containers</b>: creditCard, bill, loan, insurance<br>
	// Read Only: true
	InterestAmount *Money `json:"interestAmount,omitempty"`

	// The field is set to true if the statement is the latest generated statement.<br><br><b>Applicable containers</b>: creditCard, bill, loan, insurance<br>
	// Read Only: true
	IsLatest *bool `json:"isLatest,omitempty"`

	// The last payment done for the previous billing cycle in the current statement period.<br><br><b>Applicable containers</b>: creditCard, bill, loan, insurance<br>
	// Read Only: true
	LastPaymentAmount *Money `json:"lastPaymentAmount,omitempty"`

	// The date on which the last payment was done during the billing cycle.<br><br><b>Applicable containers</b>: creditCard, bill, loan, insurance<br>
	// Read Only: true
	LastPaymentDate string `json:"lastPaymentDate,omitempty"`

	// The date when the account was last updated by Yodlee.<br><br><b>Applicable containers</b>: creditCard, bill, loan, insurance<br>
	// Read Only: true
	LastUpdated string `json:"lastUpdated,omitempty"`

	// The outstanding principal balance on the loan account.<br><br><b>Applicable containers</b>: creditCard, bill, loan, insurance<br>
	// Read Only: true
	LoanBalance *Money `json:"loanBalance,omitempty"`

	// <b>Credit Card:</b> The minimum amount that the consumer has to pay every month on the credit card account. Data provides an up-to-date information to the consumer.<br><br><b>Applicable containers</b>: creditCard, bill, loan, insurance<br>
	// Read Only: true
	MinimumPayment *Money `json:"minimumPayment,omitempty"`

	// New charges on the statement (i.e., charges since last statement to end of the billing period). Applicable to line of credit loan type.<br><br><b>Applicable containers</b>: creditCard, bill, loan, insurance<br>
	// Read Only: true
	NewCharges *Money `json:"newCharges,omitempty"`

	// The principal amount that is part of the amount due or the payment amount.<br><br><b>Applicable containers</b>: creditCard, bill, loan, insurance<br>
	// Read Only: true
	PrincipalAmount *Money `json:"principalAmount,omitempty"`

	// The date on which the statement is generated.<br><br><b>Applicable containers</b>: creditCard, bill, loan, insurance<br>
	// Read Only: true
	StatementDate string `json:"statementDate,omitempty"`
}

// Validate validates this statement
func (m *Statement) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmountDue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCashAdvance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInterestAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastPaymentAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLoanBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMinimumPayment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNewCharges(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrincipalAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Statement) validateAmountDue(formats strfmt.Registry) error {

	if swag.IsZero(m.AmountDue) { // not required
		return nil
	}

	if m.AmountDue != nil {
		if err := m.AmountDue.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("amountDue")
			}
			return err
		}
	}

	return nil
}

func (m *Statement) validateCashAdvance(formats strfmt.Registry) error {

	if swag.IsZero(m.CashAdvance) { // not required
		return nil
	}

	if m.CashAdvance != nil {
		if err := m.CashAdvance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cashAdvance")
			}
			return err
		}
	}

	return nil
}

func (m *Statement) validateInterestAmount(formats strfmt.Registry) error {

	if swag.IsZero(m.InterestAmount) { // not required
		return nil
	}

	if m.InterestAmount != nil {
		if err := m.InterestAmount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("interestAmount")
			}
			return err
		}
	}

	return nil
}

func (m *Statement) validateLastPaymentAmount(formats strfmt.Registry) error {

	if swag.IsZero(m.LastPaymentAmount) { // not required
		return nil
	}

	if m.LastPaymentAmount != nil {
		if err := m.LastPaymentAmount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lastPaymentAmount")
			}
			return err
		}
	}

	return nil
}

func (m *Statement) validateLoanBalance(formats strfmt.Registry) error {

	if swag.IsZero(m.LoanBalance) { // not required
		return nil
	}

	if m.LoanBalance != nil {
		if err := m.LoanBalance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("loanBalance")
			}
			return err
		}
	}

	return nil
}

func (m *Statement) validateMinimumPayment(formats strfmt.Registry) error {

	if swag.IsZero(m.MinimumPayment) { // not required
		return nil
	}

	if m.MinimumPayment != nil {
		if err := m.MinimumPayment.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("minimumPayment")
			}
			return err
		}
	}

	return nil
}

func (m *Statement) validateNewCharges(formats strfmt.Registry) error {

	if swag.IsZero(m.NewCharges) { // not required
		return nil
	}

	if m.NewCharges != nil {
		if err := m.NewCharges.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("newCharges")
			}
			return err
		}
	}

	return nil
}

func (m *Statement) validatePrincipalAmount(formats strfmt.Registry) error {

	if swag.IsZero(m.PrincipalAmount) { // not required
		return nil
	}

	if m.PrincipalAmount != nil {
		if err := m.PrincipalAmount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("principalAmount")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Statement) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Statement) UnmarshalBinary(b []byte) error {
	var res Statement
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
