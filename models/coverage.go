// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Coverage Coverage
// swagger:model Coverage
type Coverage struct {

	// The coverage amount-related details.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance,investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	Amount []*CoverageAmount `json:"amount"`

	// The date on which the coverage for the account ends or expires.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance,investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	EndDate string `json:"endDate,omitempty"`

	// The plan type for an insurance provided to an individual or an entity.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values:</b><br>
	// * PPO: A plan type for health insurance that allows participants to utilize the services of any provider within their network.<br>
	// * HMO: A plan type for health insurance that allows participants to utilize the receive medical services from an assigned provider only.<br>
	// Read Only: true
	// Enum: [PPO HMO]
	PlanType string `json:"planType,omitempty"`

	// The date on which the coverage for the account starts.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance,investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul>
	// Read Only: true
	StartDate string `json:"startDate,omitempty"`

	// The type of coverage provided to an individual or an entity.<br><br><b>Aggregated / Manual</b>: Aggregated<br><b>Applicable containers</b>: insurance,investment<br><b>Endpoints</b>:<ul><li>GET accounts</li><li>GET accounts/{accountId}</li></ul><b>Applicable Values:</b><br>
	// * VISION: A type of coverage under health insurance that covers some or all costs of routine vision care.<br>
	// * DENTAL: A type of coverage under health insurance that covers some or all costs of routine dental care.<br>
	// * HEALTH: A type of coverage under health insurance that covers some or all costs of health care.<br>
	// * DEATH_COVER: A type of coverage that applies only to superannuation fund and life insurance and provides death benefits as part of the coverage.<br>
	// * TOTAL_PERMANENT_DISABILITY: A type of coverage that applies only to superannuation fund and life insurance accounts and provides disability benefits as part of the coverage.<br>
	// * ACCIDENTAL_DEATH_COVER: A type of coverage that applies only to life insurance accounts and provides accidental death benefits as part of the coverage.<br>
	// * INCOME_PROTECTION: A type of coverage that is provided to the owner of the superannuation fund. The income protection cover is available up to a percentage of the monthly income to provide an affordable-level of financial protection in the event of sickness or injury.<br>
	// * DEATH_TOTAL_PERMANENT_DISABILITY: A type of coverage provided as part of the superannuation fund. This coverage includes the benefits of both disability and death.<br>
	// Read Only: true
	// Enum: [VISION DENTAL HEALTH DEATH_COVER TOTAL_PERMANENT_DISABILITY ACCIDENTAL_DEATH_COVER INCOME_PROTECTION DEATH_TOTAL_PERMANENT_DISABILITY]
	Type string `json:"type,omitempty"`
}

// Validate validates this coverage
func (m *Coverage) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlanType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Coverage) validateAmount(formats strfmt.Registry) error {

	if swag.IsZero(m.Amount) { // not required
		return nil
	}

	for i := 0; i < len(m.Amount); i++ {
		if swag.IsZero(m.Amount[i]) { // not required
			continue
		}

		if m.Amount[i] != nil {
			if err := m.Amount[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("amount" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var coverageTypePlanTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PPO","HMO"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		coverageTypePlanTypePropEnum = append(coverageTypePlanTypePropEnum, v)
	}
}

const (

	// CoveragePlanTypePPO captures enum value "PPO"
	CoveragePlanTypePPO string = "PPO"

	// CoveragePlanTypeHMO captures enum value "HMO"
	CoveragePlanTypeHMO string = "HMO"
)

// prop value enum
func (m *Coverage) validatePlanTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, coverageTypePlanTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Coverage) validatePlanType(formats strfmt.Registry) error {

	if swag.IsZero(m.PlanType) { // not required
		return nil
	}

	// value enum
	if err := m.validatePlanTypeEnum("planType", "body", m.PlanType); err != nil {
		return err
	}

	return nil
}

var coverageTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["VISION","DENTAL","HEALTH","DEATH_COVER","TOTAL_PERMANENT_DISABILITY","ACCIDENTAL_DEATH_COVER","INCOME_PROTECTION","DEATH_TOTAL_PERMANENT_DISABILITY"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		coverageTypeTypePropEnum = append(coverageTypeTypePropEnum, v)
	}
}

const (

	// CoverageTypeVISION captures enum value "VISION"
	CoverageTypeVISION string = "VISION"

	// CoverageTypeDENTAL captures enum value "DENTAL"
	CoverageTypeDENTAL string = "DENTAL"

	// CoverageTypeHEALTH captures enum value "HEALTH"
	CoverageTypeHEALTH string = "HEALTH"

	// CoverageTypeDEATHCOVER captures enum value "DEATH_COVER"
	CoverageTypeDEATHCOVER string = "DEATH_COVER"

	// CoverageTypeTOTALPERMANENTDISABILITY captures enum value "TOTAL_PERMANENT_DISABILITY"
	CoverageTypeTOTALPERMANENTDISABILITY string = "TOTAL_PERMANENT_DISABILITY"

	// CoverageTypeACCIDENTALDEATHCOVER captures enum value "ACCIDENTAL_DEATH_COVER"
	CoverageTypeACCIDENTALDEATHCOVER string = "ACCIDENTAL_DEATH_COVER"

	// CoverageTypeINCOMEPROTECTION captures enum value "INCOME_PROTECTION"
	CoverageTypeINCOMEPROTECTION string = "INCOME_PROTECTION"

	// CoverageTypeDEATHTOTALPERMANENTDISABILITY captures enum value "DEATH_TOTAL_PERMANENT_DISABILITY"
	CoverageTypeDEATHTOTALPERMANENTDISABILITY string = "DEATH_TOTAL_PERMANENT_DISABILITY"
)

// prop value enum
func (m *Coverage) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, coverageTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Coverage) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Coverage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Coverage) UnmarshalBinary(b []byte) error {
	var res Coverage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
