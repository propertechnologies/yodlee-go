// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TransactionCategory TransactionCategory
// swagger:model TransactionCategory
type TransactionCategory struct {

	// The name of the category.<br><b>Note</b>: Transaction categorization is one of the core features offered by Yodlee and the categories are assigned to the transactions by the system. Transactions can be clubbed together by the category that is assigned to them.  <br><br><b>Applicable containers</b>: bill, creditCard, investment, insurance, loan<br>
	// Read Only: true
	Category string `json:"category,omitempty"`

	// Category Classification.<br><br><b>Applicable containers</b>: bill, creditCard, investment, insurance, loan<br><b>Applicable Values</b><br>
	// Read Only: true
	// Enum: [PERSONAL SMALL_BUSINESS]
	Classification string `json:"classification,omitempty"`

	// Entity that provides detail category attributes<br><br><b>Applicable containers</b>: bill, creditCard, investment, insurance, loan<br>
	// Read Only: true
	DetailCategory []*DetailCategory `json:"detailCategory"`

	// The unique identifier of the high level category.<br><br><b>Applicable containers</b>: bill, creditCard, investment, insurance, loan<br>
	// Read Only: true
	HighLevelCategoryID int64 `json:"highLevelCategoryId,omitempty"`

	// The name of the high level category. A group of similar transaction categories are clubbed together to form a high-level category.<br><br><b>Applicable containers</b>: bill, creditCard, investment, insurance, loan<br>
	// Read Only: true
	HighLevelCategoryName string `json:"highLevelCategoryName,omitempty"`

	// Unique identifier of the category.<br><br><b>Applicable containers</b>: bill, creditCard, investment, insurance, loan<br>
	// Read Only: true
	ID int64 `json:"id,omitempty"`

	// Source used to identify whether the transaction category is user defined category or system created category.<br><br><b>Applicable containers</b>: bill, creditCard, investment, insurance, loan<br><b>Applicable Values</b><br>
	// * SYSTEM: The category assigned to the transaction is a system defined category.<br>
	// * USER: The category assigned to the transaction is a user defined category.<br>
	// Read Only: true
	// Enum: [SYSTEM USER]
	Source string `json:"source,omitempty"`

	// Transaction categories and high-level categories are further mapped to five transaction category types. Customers, based on their needs can either use the transaction categories, the high-level categories, or the transaction category types. <br><br><b>Applicable containers</b>: bill, creditCard, investment, insurance, loan<br><b>Applicable Values</b><br>
	// * TRANSFER: The transaction category belongs to a transfer category type.<br>
	// * DEFERRED_COMPENSATION: The transaction category belongs to deferred compensation type.<br>
	// * UNCATEGORIZE: The transaction does not seem to be categorized.<br>
	// * INCOME: The transaction category belongs to an income type.<br>
	// * EXPENSE: The transaction category belongs to an expense type.<br>
	// Read Only: true
	// Enum: [TRANSFER DEFERRED_COMPENSATION UNCATEGORIZE INCOME EXPENSE]
	Type string `json:"type,omitempty"`
}

// Validate validates this transaction category
func (m *TransactionCategory) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClassification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDetailCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var transactionCategoryTypeClassificationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PERSONAL","SMALL_BUSINESS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionCategoryTypeClassificationPropEnum = append(transactionCategoryTypeClassificationPropEnum, v)
	}
}

const (

	// TransactionCategoryClassificationPERSONAL captures enum value "PERSONAL"
	TransactionCategoryClassificationPERSONAL string = "PERSONAL"

	// TransactionCategoryClassificationSMALLBUSINESS captures enum value "SMALL_BUSINESS"
	TransactionCategoryClassificationSMALLBUSINESS string = "SMALL_BUSINESS"
)

// prop value enum
func (m *TransactionCategory) validateClassificationEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, transactionCategoryTypeClassificationPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *TransactionCategory) validateClassification(formats strfmt.Registry) error {

	if swag.IsZero(m.Classification) { // not required
		return nil
	}

	// value enum
	if err := m.validateClassificationEnum("classification", "body", m.Classification); err != nil {
		return err
	}

	return nil
}

func (m *TransactionCategory) validateDetailCategory(formats strfmt.Registry) error {

	if swag.IsZero(m.DetailCategory) { // not required
		return nil
	}

	for i := 0; i < len(m.DetailCategory); i++ {
		if swag.IsZero(m.DetailCategory[i]) { // not required
			continue
		}

		if m.DetailCategory[i] != nil {
			if err := m.DetailCategory[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("detailCategory" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var transactionCategoryTypeSourcePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SYSTEM","USER"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionCategoryTypeSourcePropEnum = append(transactionCategoryTypeSourcePropEnum, v)
	}
}

// prop value enum
func (m *TransactionCategory) validateSourceEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, transactionCategoryTypeSourcePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *TransactionCategory) validateSource(formats strfmt.Registry) error {

	if swag.IsZero(m.Source) { // not required
		return nil
	}

	// value enum
	if err := m.validateSourceEnum("source", "body", m.Source); err != nil {
		return err
	}

	return nil
}

var transactionCategoryTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TRANSFER","DEFERRED_COMPENSATION","UNCATEGORIZE","INCOME","EXPENSE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionCategoryTypeTypePropEnum = append(transactionCategoryTypeTypePropEnum, v)
	}
}

// prop value enum
func (m *TransactionCategory) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, transactionCategoryTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *TransactionCategory) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TransactionCategory) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TransactionCategory) UnmarshalBinary(b []byte) error {
	var res TransactionCategory
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
