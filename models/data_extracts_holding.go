// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DataExtractsHolding DataExtractsHolding
// swagger:model DataExtractsHolding
type DataExtractsHolding struct {

	// Unique identifier of the account to which the security is linked.<br><br><b>Applicable containers</b>: investment, insurance<br>
	// Read Only: true
	AccountID int64 `json:"accountId,omitempty"`

	// The accruedIncome of the  holding.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	AccruedIncome *Money `json:"accruedIncome,omitempty"`

	// The accruedInterest of the  holding.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	AccruedInterest *Money `json:"accruedInterest,omitempty"`

	// Asset classification applied to the holding. <br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	AssetClassification []*AssetClassification `json:"assetClassification"`

	// The quantity of tradeable units in a contract.<br><b>Note</b>: The contract quantity field is only applicable to commodity and currency.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	ContractQuantity float64 `json:"contractQuantity,omitempty"`

	// In a one-off security purchase, the cost basis is the quantity acquired multiplied by the price per unit paid plus any commission paid. In case, the same position is acquired in different lots on different days at different prices, the sum total of the cost incurred is divided by the total units acquired to arrive at the average cost basis.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	CostBasis *Money `json:"costBasis,omitempty"`

	// The stated interest rate for a bond.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	CouponRate float64 `json:"couponRate,omitempty"`

	// The date on which the holding is created in the Yodlee system.<br><br><b>Applicable containers</b>: investment, insurance<br>
	// Read Only: true
	CreatedDate string `json:"createdDate,omitempty"`

	// The CUSIP (Committee on Uniform Securities Identification Procedures) identifies most the financial instruments in the United States and Canada.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	CusipNumber string `json:"cusipNumber,omitempty"`

	// The description (name) for the holding (E.g., Cisco Systems)<br>For insurance container, the field is only applicable for insurance annuity and variable life insurance types. <br><br><b>Applicable containers</b>: investment, insurance<br>
	// Read Only: true
	Description string `json:"description,omitempty"`

	// The quantity of the employee stock options that are already exercised or bought by the employee.<br><b>Note</b>: Once the employee stock options is exercised, they are either converted to cash value or equity positions depending on the FI. The exercised quantity field is only applicable to employee stock options.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	ExercisedQuantity float64 `json:"exercisedQuantity,omitempty"`

	// The date on which an option, right or warrant expires.<br><b>Note</b>: The expiration date field is only applicable to options and employee stock options.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	ExpirationDate string `json:"expirationDate,omitempty"`

	// The date on which equity awards like ESOP, RSU, etc., are issued or granted.<br><b>Note</b>: The grant date field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	GrantDate string `json:"grantDate,omitempty"`

	// Type of holding<br><br><b>Applicable containers</b>: investment, insurance<br>
	// Read Only: true
	// Enum: [stock mutualFund bond CD option moneyMarketFund other remic future commodity currency unitInvestmentTrust employeeStockOption insuranceAnnuity unknown preferredStock ETF warrants ETN]
	HoldingType string `json:"holdingType,omitempty"`

	// Unique identifier for the security added in the system. This is the primary key of the holding resource.<br><br><b>Applicable containers</b>: investment, insurance<br>
	// Read Only: true
	ID int64 `json:"id,omitempty"`

	// The interest rate on a CD.<br><b>Note</b>: The interest rate field is only applicable to CD.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	InterestRate float64 `json:"interestRate,omitempty"`

	// Indicates if the holding is marked as deleted.<b>Applicable containers</b>: investment, insurance<br><b>Endpoints</b>:<br><ul><li>GET dataExtracts/userData</li></ul>
	// Read Only: true
	IsDeleted *bool `json:"isDeleted,omitempty"`

	// Indicates that the holding is a short trading.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	IsShort *bool `json:"isShort,omitempty"`

	// The ISIN (International Securities Identification Number) is used worldwide to identify specific securities. It is equivalent to CUSIP for international markets.<br><br><b>Note</b>: The ISIN field is only applicable to the trade related transactions<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	Isin string `json:"isin,omitempty"`

	// The date when the information was last updated in the system.<br><br><b>Applicable containers</b>: investment, insurance<br>
	// Read Only: true
	LastUpdated string `json:"lastUpdated,omitempty"`

	// Indicates the security match status id of the investment option identified during security normalization.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	MatchStatus string `json:"matchStatus,omitempty"`

	// The stated maturity date of a bond or CD.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	MaturityDate string `json:"maturityDate,omitempty"`

	// The type of the option position (i.e., put or call).<br><b>Note</b>: The option type field is only applicable to options.<br><br><b>Applicable containers</b>: investment<br><b>Applicable Values</b><br>
	// * put: An option to sell assets at an agreed price on or before a particular date.<br>
	// * call: An option to buy assets at an agreed price on or before a particular date.<br>
	// Read Only: true
	// Enum: [put call]
	OptionType string `json:"optionType,omitempty"`

	// The current price of the security.<br><b>Note</b>: Only for bonds the price field indicates the normalized price and not the price aggregated from the site. For insurance container, the field is only applicable for insurance annuity and variable life insurance types.<br><br><b>Applicable containers</b>: investment, insurance<br>
	// Read Only: true
	Price *Money `json:"price,omitempty"`

	// Unique identifier for the user's association with the provider.<br><br><b>Applicable containers</b>: investment, insurance<br>
	// Read Only: true
	ProviderAccountID int64 `json:"providerAccountId,omitempty"`

	// The quantity held for the holding.<br><b>Note</b>: Only for bonds the quantity field indicates the normalized quantity and not the quantity aggregated from the site. The quantity field is only applicable to restricted stock units/awards, performance units, currency, and commodity.<br>For insurance container, the field is only applicable for insurance annuity and variable life insurance types.<br><br><b>Applicable containers</b>: investment, insurance<br>
	// Read Only: true
	Quantity float64 `json:"quantity,omitempty"`

	// Indicates the security type of holding identified through the security service.<br><br><b>Applicable containers</b>: investment, insurance<br>
	// Read Only: true
	SecurityType string `json:"securityType,omitempty"`

	// The SEDOL (Stock Exchange Daily Official List) is a set of security identifiers used in the United Kingdom and Ireland for clearing purposes.<br><b>Note</b>: The SEDOL field is only applicable to the trade related transactions<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	Sedol string `json:"sedol,omitempty"`

	// The difference between the current market value of a stock and the strike price of the employee stock option, when the market value of the shares are greater than the stock price.<br><b>Note</b>: The spread field is only applicable to employee stock options.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	Spread *Money `json:"spread,omitempty"`

	// The strike (exercise) price for the option position.<br><b>Note</b>: The strike price field is only applicable to options and employee stock options.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	StrikePrice *Money `json:"strikePrice,omitempty"`

	// The symbol of the security.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	Symbol string `json:"symbol,omitempty"`

	// The fixed duration for which the bond or CD is issued.<br><b>Note</b>: The term field is only applicable to CD.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	Term string `json:"term,omitempty"`

	// Indicates the number of unvested quantity or units.<br><b>Note</b>: The unvested quantity field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	UnvestedQuantity float64 `json:"unvestedQuantity,omitempty"`

	// Indicates the estimated market value of the unvested units.<br><b>Note</b>: FIs usually calculates the unvested value as the market price unvested quantity. The unvested value field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	UnvestedValue *Money `json:"unvestedValue,omitempty"`

	// The total market value of the security. For insurance container, the field is only applicable for insurance annuity and variable life insurance types.<br><br><b>Applicable containers</b>: investment, insurance<br>
	// Read Only: true
	Value *Money `json:"value,omitempty"`

	// The quantity of units or shares that are already vested on a vest date.<br><b>Note</b>: The vested quantity field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	VestedQuantity float64 `json:"vestedQuantity,omitempty"`

	// The number of vested shares that can be exercised by the employee. It is usually equal to the vested quantity.<br><b>Note</b>: The vested shares exercisable field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	VestedSharesExercisable float64 `json:"vestedSharesExercisable,omitempty"`

	// Indicates the estimated market value of the vested units.<br><b>Note</b>: FIs usually calculates the vested value as the market price vested quantity. The vested value field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	VestedValue *Money `json:"vestedValue,omitempty"`

	// The date on which a RSU, RSA, or an employee stock options become vested.<br><b>Note</b>: The vesting date field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.<br><br><b>Applicable containers</b>: investment<br>
	// Read Only: true
	VestingDate string `json:"vestingDate,omitempty"`
}

// Validate validates this data extracts holding
func (m *DataExtractsHolding) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccruedIncome(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccruedInterest(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAssetClassification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCostBasis(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHoldingType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpread(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStrikePrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUnvestedValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVestedValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataExtractsHolding) validateAccruedIncome(formats strfmt.Registry) error {

	if swag.IsZero(m.AccruedIncome) { // not required
		return nil
	}

	if m.AccruedIncome != nil {
		if err := m.AccruedIncome.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("accruedIncome")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsHolding) validateAccruedInterest(formats strfmt.Registry) error {

	if swag.IsZero(m.AccruedInterest) { // not required
		return nil
	}

	if m.AccruedInterest != nil {
		if err := m.AccruedInterest.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("accruedInterest")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsHolding) validateAssetClassification(formats strfmt.Registry) error {

	if swag.IsZero(m.AssetClassification) { // not required
		return nil
	}

	for i := 0; i < len(m.AssetClassification); i++ {
		if swag.IsZero(m.AssetClassification[i]) { // not required
			continue
		}

		if m.AssetClassification[i] != nil {
			if err := m.AssetClassification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("assetClassification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataExtractsHolding) validateCostBasis(formats strfmt.Registry) error {

	if swag.IsZero(m.CostBasis) { // not required
		return nil
	}

	if m.CostBasis != nil {
		if err := m.CostBasis.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("costBasis")
			}
			return err
		}
	}

	return nil
}

var dataExtractsHoldingTypeHoldingTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["stock","mutualFund","bond","CD","option","moneyMarketFund","other","remic","future","commodity","currency","unitInvestmentTrust","employeeStockOption","insuranceAnnuity","unknown","preferredStock","ETF","warrants","ETN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataExtractsHoldingTypeHoldingTypePropEnum = append(dataExtractsHoldingTypeHoldingTypePropEnum, v)
	}
}

const (

	// DataExtractsHoldingHoldingTypeStock captures enum value "stock"
	DataExtractsHoldingHoldingTypeStock string = "stock"

	// DataExtractsHoldingHoldingTypeMutualFund captures enum value "mutualFund"
	DataExtractsHoldingHoldingTypeMutualFund string = "mutualFund"

	// DataExtractsHoldingHoldingTypeBond captures enum value "bond"
	DataExtractsHoldingHoldingTypeBond string = "bond"

	// DataExtractsHoldingHoldingTypeCD captures enum value "CD"
	DataExtractsHoldingHoldingTypeCD string = "CD"

	// DataExtractsHoldingHoldingTypeOption captures enum value "option"
	DataExtractsHoldingHoldingTypeOption string = "option"

	// DataExtractsHoldingHoldingTypeMoneyMarketFund captures enum value "moneyMarketFund"
	DataExtractsHoldingHoldingTypeMoneyMarketFund string = "moneyMarketFund"

	// DataExtractsHoldingHoldingTypeOther captures enum value "other"
	DataExtractsHoldingHoldingTypeOther string = "other"

	// DataExtractsHoldingHoldingTypeRemic captures enum value "remic"
	DataExtractsHoldingHoldingTypeRemic string = "remic"

	// DataExtractsHoldingHoldingTypeFuture captures enum value "future"
	DataExtractsHoldingHoldingTypeFuture string = "future"

	// DataExtractsHoldingHoldingTypeCommodity captures enum value "commodity"
	DataExtractsHoldingHoldingTypeCommodity string = "commodity"

	// DataExtractsHoldingHoldingTypeCurrency captures enum value "currency"
	DataExtractsHoldingHoldingTypeCurrency string = "currency"

	// DataExtractsHoldingHoldingTypeUnitInvestmentTrust captures enum value "unitInvestmentTrust"
	DataExtractsHoldingHoldingTypeUnitInvestmentTrust string = "unitInvestmentTrust"

	// DataExtractsHoldingHoldingTypeEmployeeStockOption captures enum value "employeeStockOption"
	DataExtractsHoldingHoldingTypeEmployeeStockOption string = "employeeStockOption"

	// DataExtractsHoldingHoldingTypeInsuranceAnnuity captures enum value "insuranceAnnuity"
	DataExtractsHoldingHoldingTypeInsuranceAnnuity string = "insuranceAnnuity"

	// DataExtractsHoldingHoldingTypeUnknown captures enum value "unknown"
	DataExtractsHoldingHoldingTypeUnknown string = "unknown"

	// DataExtractsHoldingHoldingTypePreferredStock captures enum value "preferredStock"
	DataExtractsHoldingHoldingTypePreferredStock string = "preferredStock"

	// DataExtractsHoldingHoldingTypeETF captures enum value "ETF"
	DataExtractsHoldingHoldingTypeETF string = "ETF"

	// DataExtractsHoldingHoldingTypeWarrants captures enum value "warrants"
	DataExtractsHoldingHoldingTypeWarrants string = "warrants"

	// DataExtractsHoldingHoldingTypeETN captures enum value "ETN"
	DataExtractsHoldingHoldingTypeETN string = "ETN"
)

// prop value enum
func (m *DataExtractsHolding) validateHoldingTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataExtractsHoldingTypeHoldingTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataExtractsHolding) validateHoldingType(formats strfmt.Registry) error {

	if swag.IsZero(m.HoldingType) { // not required
		return nil
	}

	// value enum
	if err := m.validateHoldingTypeEnum("holdingType", "body", m.HoldingType); err != nil {
		return err
	}

	return nil
}

var dataExtractsHoldingTypeOptionTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["put","call"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataExtractsHoldingTypeOptionTypePropEnum = append(dataExtractsHoldingTypeOptionTypePropEnum, v)
	}
}

const (

	// DataExtractsHoldingOptionTypePut captures enum value "put"
	DataExtractsHoldingOptionTypePut string = "put"

	// DataExtractsHoldingOptionTypeCall captures enum value "call"
	DataExtractsHoldingOptionTypeCall string = "call"
)

// prop value enum
func (m *DataExtractsHolding) validateOptionTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataExtractsHoldingTypeOptionTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataExtractsHolding) validateOptionType(formats strfmt.Registry) error {

	if swag.IsZero(m.OptionType) { // not required
		return nil
	}

	// value enum
	if err := m.validateOptionTypeEnum("optionType", "body", m.OptionType); err != nil {
		return err
	}

	return nil
}

func (m *DataExtractsHolding) validatePrice(formats strfmt.Registry) error {

	if swag.IsZero(m.Price) { // not required
		return nil
	}

	if m.Price != nil {
		if err := m.Price.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("price")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsHolding) validateSpread(formats strfmt.Registry) error {

	if swag.IsZero(m.Spread) { // not required
		return nil
	}

	if m.Spread != nil {
		if err := m.Spread.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spread")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsHolding) validateStrikePrice(formats strfmt.Registry) error {

	if swag.IsZero(m.StrikePrice) { // not required
		return nil
	}

	if m.StrikePrice != nil {
		if err := m.StrikePrice.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("strikePrice")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsHolding) validateUnvestedValue(formats strfmt.Registry) error {

	if swag.IsZero(m.UnvestedValue) { // not required
		return nil
	}

	if m.UnvestedValue != nil {
		if err := m.UnvestedValue.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("unvestedValue")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsHolding) validateValue(formats strfmt.Registry) error {

	if swag.IsZero(m.Value) { // not required
		return nil
	}

	if m.Value != nil {
		if err := m.Value.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("value")
			}
			return err
		}
	}

	return nil
}

func (m *DataExtractsHolding) validateVestedValue(formats strfmt.Registry) error {

	if swag.IsZero(m.VestedValue) { // not required
		return nil
	}

	if m.VestedValue != nil {
		if err := m.VestedValue.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vestedValue")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataExtractsHolding) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataExtractsHolding) UnmarshalBinary(b []byte) error {
	var res DataExtractsHolding
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
